
Scanalogic2_test_board.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  0000167a  0000172e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000167a  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bootloader   000007de  00003800  00003800  00001730  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .bss          00000159  00800102  00800102  00001f0e  2**0
                  ALLOC
  4 .debug_aranges 00000178  00000000  00000000  00001f10  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 00001100  00000000  00000000  00002088  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000255a  00000000  00000000  00003188  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000826  00000000  00000000  000056e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001d4b  00000000  00000000  00005f08  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000260  00000000  00000000  00007c54  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000090b  00000000  00000000  00007eb4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000bba  00000000  00000000  000087bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000148  00000000  00000000  00009379  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 6f 00 	jmp	0xde	; 0xde <__ctors_end>
       4:	0c 94 bf 08 	jmp	0x117e	; 0x117e <__vector_1>
       8:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
       c:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      10:	0c 94 10 0a 	jmp	0x1420	; 0x1420 <__vector_4>
      14:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      18:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      1c:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      20:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      24:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      28:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      2c:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      30:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      34:	0c 94 f8 09 	jmp	0x13f0	; 0x13f0 <__vector_13>
      38:	0c 94 27 0a 	jmp	0x144e	; 0x144e <__vector_14>
      3c:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      40:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      44:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      48:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      4c:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      50:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      54:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      58:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      5c:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      60:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>
      64:	0c 94 8c 00 	jmp	0x118	; 0x118 <__bad_interrupt>

00000068 <usbDescriptorString0>:
      68:	04 03 09 04                                         ....

0000006c <usbDescriptorStringVendor>:
      6c:	12 03 69 00 6b 00 61 00 6c 00 6f 00 67 00 69 00     ..i.k.a.l.o.g.i.
      7c:	63 00                                               c.

0000007e <usbDescriptorStringDevice>:
      7e:	16 03 53 00 43 00 41 00 4e 00 41 00 4c 00 4f 00     ..S.C.A.N.A.L.O.
      8e:	47 00 49 00 43 00                                   G.I.C.

00000094 <usbDescriptorDevice>:
      94:	12 01 10 01 00 00 00 08 a0 20 23 41 00 01 01 02     ......... #A....
      a4:	00 01                                               ..

000000a6 <usbDescriptorConfiguration>:
      a6:	09 02 22 00 01 01 00 80 32 09 04 00 00 01 03 00     ..".....2.......
      b6:	00 00 09 21 01 01 00 01 22 16 00 07 05 81 03 08     ...!....".......
      c6:	00 64                                               .d

000000c8 <usbDescriptorHidReport>:
      c8:	06 00 ff 09 01 a1 01 15 00 26 ff 00 75 08 95 80     .........&..u...
      d8:	09 00 b2 02 01 c0                                   ......

000000de <__ctors_end>:
      de:	11 24       	eor	r1, r1
      e0:	1f be       	out	0x3f, r1	; 63
      e2:	cf ef       	ldi	r28, 0xFF	; 255
      e4:	d4 e0       	ldi	r29, 0x04	; 4
      e6:	de bf       	out	0x3e, r29	; 62
      e8:	cd bf       	out	0x3d, r28	; 61

000000ea <__do_copy_data>:
      ea:	11 e0       	ldi	r17, 0x01	; 1
      ec:	a0 e0       	ldi	r26, 0x00	; 0
      ee:	b1 e0       	ldi	r27, 0x01	; 1
      f0:	ea e7       	ldi	r30, 0x7A	; 122
      f2:	f6 e1       	ldi	r31, 0x16	; 22
      f4:	02 c0       	rjmp	.+4      	; 0xfa <.do_copy_data_start>

000000f6 <.do_copy_data_loop>:
      f6:	05 90       	lpm	r0, Z+
      f8:	0d 92       	st	X+, r0

000000fa <.do_copy_data_start>:
      fa:	a2 30       	cpi	r26, 0x02	; 2
      fc:	b1 07       	cpc	r27, r17
      fe:	d9 f7       	brne	.-10     	; 0xf6 <.do_copy_data_loop>

00000100 <__do_clear_bss>:
     100:	12 e0       	ldi	r17, 0x02	; 2
     102:	a2 e0       	ldi	r26, 0x02	; 2
     104:	b1 e0       	ldi	r27, 0x01	; 1
     106:	01 c0       	rjmp	.+2      	; 0x10a <.do_clear_bss_start>

00000108 <.do_clear_bss_loop>:
     108:	1d 92       	st	X+, r1

0000010a <.do_clear_bss_start>:
     10a:	ab 35       	cpi	r26, 0x5B	; 91
     10c:	b1 07       	cpc	r27, r17
     10e:	e1 f7       	brne	.-8      	; 0x108 <.do_clear_bss_loop>
     110:	0e 94 8e 00 	call	0x11c	; 0x11c <main>
     114:	0c 94 3b 0b 	jmp	0x1676	; 0x1676 <_exit>

00000118 <__bad_interrupt>:
     118:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000011c <main>:


		volatile uchar test,t2;		

int main(void)
{ 
     11c:	2f 92       	push	r2
     11e:	3f 92       	push	r3
     120:	4f 92       	push	r4
     122:	5f 92       	push	r5
     124:	6f 92       	push	r6
     126:	7f 92       	push	r7
     128:	8f 92       	push	r8
     12a:	9f 92       	push	r9
     12c:	af 92       	push	r10
     12e:	bf 92       	push	r11
     130:	cf 92       	push	r12
     132:	df 92       	push	r13
     134:	ef 92       	push	r14
     136:	ff 92       	push	r15
     138:	0f 93       	push	r16
     13a:	1f 93       	push	r17
     13c:	df 93       	push	r29
     13e:	cf 93       	push	r28
     140:	cd b7       	in	r28, 0x3d	; 61
     142:	de b7       	in	r29, 0x3e	; 62
     144:	28 97       	sbiw	r28, 0x08	; 8
     146:	0f b6       	in	r0, 0x3f	; 63
     148:	f8 94       	cli
     14a:	de bf       	out	0x3e, r29	; 62
     14c:	0f be       	out	0x3f, r0	; 63
     14e:	cd bf       	out	0x3d, r28	; 61
		volatile uchar i,j;
		volatile uchar signature;
		volatile unsigned int trigger_count_delay,delay_count;
		//sram_internal_clk(0x14, 0xFF,0xFF); // prohibit SPM
		//
		sram_sequence_busy = 0;
     150:	10 92 12 01 	sts	0x0112, r1
		//wdt_disable();
		MCUSR &= ~(1<<WDRF);
     154:	84 b7       	in	r24, 0x34	; 52
     156:	87 7f       	andi	r24, 0xF7	; 247
     158:	84 bf       	out	0x34, r24	; 52
		WDTCSR |= (1<<WDCE) | (1<<WDE); //Start timed sequence to edit watchdog configuration
     15a:	80 91 60 00 	lds	r24, 0x0060
     15e:	88 61       	ori	r24, 0x18	; 24
     160:	80 93 60 00 	sts	0x0060, r24
		WDTCSR = 0;
     164:	10 92 60 00 	sts	0x0060, r1
     168:	80 ed       	ldi	r24, 0xD0	; 208
     16a:	97 e0       	ldi	r25, 0x07	; 7
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     16c:	24 ef       	ldi	r18, 0xF4	; 244
     16e:	31 e0       	ldi	r19, 0x01	; 1
     170:	f9 01       	movw	r30, r18
     172:	31 97       	sbiw	r30, 0x01	; 1
     174:	f1 f7       	brne	.-4      	; 0x172 <main+0x56>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     176:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     178:	d9 f7       	brne	.-10     	; 0x170 <main+0x54>
		_delay_ms(200);
		cli();
     17a:	f8 94       	cli
    usbInit();
     17c:	0e 94 49 07 	call	0xe92	; 0xe92 <usbInit>
		
		usbDeviceDisconnect();  /* enforce re-enumeration, do this while interrupts are disabled! */
     180:	3d 98       	cbi	0x07, 5	; 7
     182:	45 98       	cbi	0x08, 5	; 8
    i = 0;
     184:	19 82       	std	Y+1, r1	; 0x01
		j = 1;
     186:	81 e0       	ldi	r24, 0x01	; 1
     188:	8a 83       	std	Y+2, r24	; 0x02
     18a:	28 e8       	ldi	r18, 0x88	; 136
     18c:	33 e1       	ldi	r19, 0x13	; 19
     18e:	03 c0       	rjmp	.+6      	; 0x196 <main+0x7a>
     190:	c9 01       	movw	r24, r18
     192:	01 97       	sbiw	r24, 0x01	; 1
     194:	f1 f7       	brne	.-4      	; 0x192 <main+0x76>
		//while(--j){             /* fake USB disconnect for > 250 ms */
		    while(--i){             /* fake USB disconnect for > 250 ms */
     196:	89 81       	ldd	r24, Y+1	; 0x01
     198:	81 50       	subi	r24, 0x01	; 1
     19a:	89 83       	std	Y+1, r24	; 0x01
     19c:	89 81       	ldd	r24, Y+1	; 0x01
     19e:	88 23       	and	r24, r24
     1a0:	b9 f7       	brne	.-18     	; 0x190 <main+0x74>
		        _delay_ms(1);
		    }
    //}
    usbDeviceConnect();
     1a2:	3d 9a       	sbi	0x07, 5	; 7
     1a4:	45 9a       	sbi	0x08, 5	; 8

		setup_timers();
     1a6:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <setup_timers>

    sei();
     1aa:	78 94       	sei

		ISOLATE_PROBES;
     1ac:	21 9a       	sbi	0x04, 1	; 4
     1ae:	29 9a       	sbi	0x05, 1	; 5
     1b0:	20 9a       	sbi	0x04, 0	; 4
     1b2:	28 9a       	sbi	0x05, 0	; 5
     1b4:	22 9a       	sbi	0x04, 2	; 4
     1b6:	2a 9a       	sbi	0x05, 2	; 5
     1b8:	24 9a       	sbi	0x04, 4	; 4
     1ba:	2c 9a       	sbi	0x05, 4	; 5

		
		DDR_CLK_ENA |= CLK_ENA; //Set CLK_ENA as output
     1bc:	27 9a       	sbi	0x04, 7	; 4
		DDR_MISO &= ~(MISO_MASK); //set MOSI pins as inputs
     1be:	8a b1       	in	r24, 0x0a	; 10
     1c0:	87 78       	andi	r24, 0x87	; 135
     1c2:	8a b9       	out	0x0a, r24	; 10
		DDR_CLK |= CLK;				//set pin as output
     1c4:	23 9a       	sbi	0x04, 3	; 4
		
		//LED_ON;
		//_delay_ms(100);
		LED_OFF;
     1c6:	50 9a       	sbi	0x0a, 0	; 10
     1c8:	58 98       	cbi	0x0b, 0	; 11
     1ca:	80 e5       	ldi	r24, 0x50	; 80
     1cc:	93 ec       	ldi	r25, 0xC3	; 195
     1ce:	01 97       	sbiw	r24, 0x01	; 1
     1d0:	f1 f7       	brne	.-4      	; 0x1ce <main+0xb2>
		//sram_cs(DIS);
		_delay_ms(10);
		//sram_high_speed_clk(DIS);
		//sram_clk(0);
		//sram_clk(0);	
		SRAM_HS_CLK_DIS;
     1d2:	2f 9a       	sbi	0x05, 7	; 5
     1d4:	23 9a       	sbi	0x04, 3	; 4
     1d6:	2b 98       	cbi	0x05, 3	; 5
     1d8:	84 e8       	ldi	r24, 0x84	; 132
     1da:	93 e0       	ldi	r25, 0x03	; 3
     1dc:	24 ef       	ldi	r18, 0xF4	; 244
     1de:	31 e0       	ldi	r19, 0x01	; 1
     1e0:	f9 01       	movw	r30, r18
     1e2:	31 97       	sbiw	r30, 0x01	; 1
     1e4:	f1 f7       	brne	.-4      	; 0x1e2 <main+0xc6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     1e6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     1e8:	d9 f7       	brne	.-10     	; 0x1e0 <main+0xc4>
		//sram_out(0,0);
		_delay_ms(90);
		//test = sram_read_status();
		sram_write_status((1<<0)|(1<<6)); //Set sequencial read/write mode
     1ea:	81 e4       	ldi	r24, 0x41	; 65
     1ec:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <sram_write_status>
     1f0:	84 e8       	ldi	r24, 0x84	; 132
     1f2:	93 e0       	ldi	r25, 0x03	; 3
     1f4:	24 ef       	ldi	r18, 0xF4	; 244
     1f6:	31 e0       	ldi	r19, 0x01	; 1
     1f8:	f9 01       	movw	r30, r18
     1fa:	31 97       	sbiw	r30, 0x01	; 1
     1fc:	f1 f7       	brne	.-4      	; 0x1fa <main+0xde>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     1fe:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     200:	d9 f7       	brne	.-10     	; 0x1f8 <main+0xdc>
		_delay_ms(90);
		sram_write_byte(0x00AA,0xA0, 0);
     202:	8a ea       	ldi	r24, 0xAA	; 170
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	60 ea       	ldi	r22, 0xA0	; 160
     208:	40 e0       	ldi	r20, 0x00	; 0
     20a:	0e 94 89 1d 	call	0x3b12	; 0x3b12 <sram_write_byte>
		sram_write_byte(0x00AA,0xA1, 1);
     20e:	8a ea       	ldi	r24, 0xAA	; 170
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	61 ea       	ldi	r22, 0xA1	; 161
     214:	41 e0       	ldi	r20, 0x01	; 1
     216:	0e 94 89 1d 	call	0x3b12	; 0x3b12 <sram_write_byte>
		sram_write_byte(0x00AA,0xA2, 2);
     21a:	8a ea       	ldi	r24, 0xAA	; 170
     21c:	90 e0       	ldi	r25, 0x00	; 0
     21e:	62 ea       	ldi	r22, 0xA2	; 162
     220:	42 e0       	ldi	r20, 0x02	; 2
     222:	0e 94 89 1d 	call	0x3b12	; 0x3b12 <sram_write_byte>
		sram_write_byte(0x00AA,0xA3, 3);
     226:	8a ea       	ldi	r24, 0xAA	; 170
     228:	90 e0       	ldi	r25, 0x00	; 0
     22a:	63 ea       	ldi	r22, 0xA3	; 163
     22c:	43 e0       	ldi	r20, 0x03	; 3
     22e:	0e 94 89 1d 	call	0x3b12	; 0x3b12 <sram_write_byte>
     232:	84 e8       	ldi	r24, 0x84	; 132
     234:	93 e0       	ldi	r25, 0x03	; 3
     236:	24 ef       	ldi	r18, 0xF4	; 244
     238:	31 e0       	ldi	r19, 0x01	; 1
     23a:	f9 01       	movw	r30, r18
     23c:	31 97       	sbiw	r30, 0x01	; 1
     23e:	f1 f7       	brne	.-4      	; 0x23c <main+0x120>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     240:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     242:	d9 f7       	brne	.-10     	; 0x23a <main+0x11e>
		_delay_ms(90);
		sram_write_byte(0x0AAA,0x0A, CH_ALL);
     244:	8a ea       	ldi	r24, 0xAA	; 170
     246:	9a e0       	ldi	r25, 0x0A	; 10
     248:	6a e0       	ldi	r22, 0x0A	; 10
     24a:	43 e6       	ldi	r20, 0x63	; 99
     24c:	0e 94 89 1d 	call	0x3b12	; 0x3b12 <sram_write_byte>
     250:	84 e8       	ldi	r24, 0x84	; 132
     252:	93 e0       	ldi	r25, 0x03	; 3
     254:	24 ef       	ldi	r18, 0xF4	; 244
     256:	31 e0       	ldi	r19, 0x01	; 1
     258:	f9 01       	movw	r30, r18
     25a:	31 97       	sbiw	r30, 0x01	; 1
     25c:	f1 f7       	brne	.-4      	; 0x25a <main+0x13e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     25e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     260:	d9 f7       	brne	.-10     	; 0x258 <main+0x13c>
		_delay_ms(90);
		//added on 08/03/2012
		sram_write_status((1<<0)|(1<<6)); //Set sequencial read/write mode
     262:	81 e4       	ldi	r24, 0x41	; 65
     264:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <sram_write_status>
     268:	84 e8       	ldi	r24, 0x84	; 132
     26a:	93 e0       	ldi	r25, 0x03	; 3
     26c:	24 ef       	ldi	r18, 0xF4	; 244
     26e:	31 e0       	ldi	r19, 0x01	; 1
     270:	f9 01       	movw	r30, r18
     272:	31 97       	sbiw	r30, 0x01	; 1
     274:	f1 f7       	brne	.-4      	; 0x272 <main+0x156>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     276:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     278:	d9 f7       	brne	.-10     	; 0x270 <main+0x154>
		_delay_ms(90);
		
		memset((void*)stream,0,128); //very important, STREAM must not contain 0's
     27a:	05 e2       	ldi	r16, 0x25	; 37
     27c:	11 e0       	ldi	r17, 0x01	; 1
     27e:	c8 01       	movw	r24, r16
     280:	60 e0       	ldi	r22, 0x00	; 0
     282:	70 e0       	ldi	r23, 0x00	; 0
     284:	40 e8       	ldi	r20, 0x80	; 128
     286:	50 e0       	ldi	r21, 0x00	; 0
     288:	0e 94 2c 0b 	call	0x1658	; 0x1658 <memset>
		stream[1] = 99;	//Tell PC i finished sending data, and/or currently IDLE
     28c:	83 e6       	ldi	r24, 0x63	; 99
     28e:	f8 2e       	mov	r15, r24
     290:	f0 92 26 01 	sts	0x0126, r15
		stream[0] = USB_FEEDBACK;
     294:	85 e0       	ldi	r24, 0x05	; 5
     296:	80 93 25 01 	sts	0x0125, r24


		my_sn[0] = eeprom_read_byte((void*)3);
     29a:	83 e0       	ldi	r24, 0x03	; 3
     29c:	90 e0       	ldi	r25, 0x00	; 0
     29e:	0e 94 33 0b 	call	0x1666	; 0x1666 <__eerd_byte_m168>
     2a2:	80 93 1a 01 	sts	0x011A, r24
		my_sn[1] = eeprom_read_byte((void*)2);
     2a6:	82 e0       	ldi	r24, 0x02	; 2
     2a8:	90 e0       	ldi	r25, 0x00	; 0
     2aa:	0e 94 33 0b 	call	0x1666	; 0x1666 <__eerd_byte_m168>
     2ae:	80 93 1b 01 	sts	0x011B, r24
		my_sn[2] = eeprom_read_byte((void*)1);
     2b2:	81 e0       	ldi	r24, 0x01	; 1
     2b4:	90 e0       	ldi	r25, 0x00	; 0
     2b6:	0e 94 33 0b 	call	0x1666	; 0x1666 <__eerd_byte_m168>
     2ba:	80 93 1c 01 	sts	0x011C, r24
		my_sn[3] = eeprom_read_byte((void*)0);
     2be:	80 e0       	ldi	r24, 0x00	; 0
     2c0:	90 e0       	ldi	r25, 0x00	; 0
     2c2:	0e 94 33 0b 	call	0x1666	; 0x1666 <__eerd_byte_m168>
     2c6:	80 93 1d 01 	sts	0x011D, r24




			state_machine= 99;
     2ca:	f0 92 23 01 	sts	0x0123, r15

			pc_connected = 0;
     2ce:	10 92 14 02 	sts	0x0214, r1
				case USB_GET_SN:
					stream[1] = my_sn[0];
					stream[2] = my_sn[1];
					stream[3] = my_sn[2];
					stream[4] = my_sn[3];
					stream[5] = FWV_MAJ;
     2d2:	55 24       	eor	r5, r5
     2d4:	53 94       	inc	r5
					stream[6] = FWV_MIN;
					//LED_ON;
					if (usb_data_read == 1) //make sure previous data have been read by HOST
						{
							//LED_OFF;
							memset((void*)stream,0,128);
     2d6:	40 2e       	mov	r4, r16
     2d8:	18 87       	std	Y+8, r17	; 0x08
     2da:	b4 ef       	ldi	r27, 0xF4	; 244
     2dc:	2b 2e       	mov	r2, r27
     2de:	b1 e0       	ldi	r27, 0x01	; 1
     2e0:	3b 2e       	mov	r3, r27
			pc_connected = 0;
   while(1)
	 {    


	 		switch(state_machine)
     2e2:	80 91 23 01 	lds	r24, 0x0123
     2e6:	88 23       	and	r24, r24
     2e8:	19 f0       	breq	.+6      	; 0x2f0 <main+0x1d4>
     2ea:	83 36       	cpi	r24, 0x63	; 99
     2ec:	09 f0       	breq	.+2      	; 0x2f0 <main+0x1d4>
     2ee:	77 c0       	rjmp	.+238    	; 0x3de <main+0x2c2>
			{
				case 99: //IDLE
				case 0: //IDLE
					//gen_mode = 0; 
					if (gen_mode == 1)
     2f0:	80 91 17 01 	lds	r24, 0x0117
     2f4:	81 30       	cpi	r24, 0x01	; 1
     2f6:	09 f4       	brne	.+2      	; 0x2fa <main+0x1de>
     2f8:	6d c0       	rjmp	.+218    	; 0x3d4 <main+0x2b8>
					{
						LED_ON;
					}
					else
					{
						idle_blink_counter++;
     2fa:	80 91 15 02 	lds	r24, 0x0215
     2fe:	90 91 16 02 	lds	r25, 0x0216
     302:	a0 91 17 02 	lds	r26, 0x0217
     306:	b0 91 18 02 	lds	r27, 0x0218
     30a:	01 96       	adiw	r24, 0x01	; 1
     30c:	a1 1d       	adc	r26, r1
     30e:	b1 1d       	adc	r27, r1
     310:	80 93 15 02 	sts	0x0215, r24
     314:	90 93 16 02 	sts	0x0216, r25
     318:	a0 93 17 02 	sts	0x0217, r26
     31c:	b0 93 18 02 	sts	0x0218, r27
						if (idle_blink_counter > 640000) 
     320:	80 91 15 02 	lds	r24, 0x0215
     324:	90 91 16 02 	lds	r25, 0x0216
     328:	a0 91 17 02 	lds	r26, 0x0217
     32c:	b0 91 18 02 	lds	r27, 0x0218
     330:	81 50       	subi	r24, 0x01	; 1
     332:	94 4c       	sbci	r25, 0xC4	; 196
     334:	a9 40       	sbci	r26, 0x09	; 9
     336:	b0 40       	sbci	r27, 0x00	; 0
     338:	40 f0       	brcs	.+16     	; 0x34a <main+0x22e>
						{
							idle_blink_counter=0;
     33a:	10 92 15 02 	sts	0x0215, r1
     33e:	10 92 16 02 	sts	0x0216, r1
     342:	10 92 17 02 	sts	0x0217, r1
     346:	10 92 18 02 	sts	0x0218, r1
						}

						if (pc_connected == 1)
     34a:	80 91 14 02 	lds	r24, 0x0214
     34e:	81 30       	cpi	r24, 0x01	; 1
     350:	a1 f5       	brne	.+104    	; 0x3ba <main+0x29e>
						{
							if ((idle_blink_counter == 0) || (idle_blink_counter == 300000))
     352:	80 91 15 02 	lds	r24, 0x0215
     356:	90 91 16 02 	lds	r25, 0x0216
     35a:	a0 91 17 02 	lds	r26, 0x0217
     35e:	b0 91 18 02 	lds	r27, 0x0218
     362:	00 97       	sbiw	r24, 0x00	; 0
     364:	a1 05       	cpc	r26, r1
     366:	b1 05       	cpc	r27, r1
     368:	69 f0       	breq	.+26     	; 0x384 <main+0x268>
     36a:	80 91 15 02 	lds	r24, 0x0215
     36e:	90 91 16 02 	lds	r25, 0x0216
     372:	a0 91 17 02 	lds	r26, 0x0217
     376:	b0 91 18 02 	lds	r27, 0x0218
     37a:	80 5e       	subi	r24, 0xE0	; 224
     37c:	93 49       	sbci	r25, 0x93	; 147
     37e:	a4 40       	sbci	r26, 0x04	; 4
     380:	b0 40       	sbci	r27, 0x00	; 0
     382:	49 f4       	brne	.+18     	; 0x396 <main+0x27a>
							{
								if (usb_alive < 0xF0) usb_alive++;
     384:	80 91 07 01 	lds	r24, 0x0107
     388:	80 3f       	cpi	r24, 0xF0	; 240
     38a:	28 f4       	brcc	.+10     	; 0x396 <main+0x27a>
     38c:	80 91 07 01 	lds	r24, 0x0107
     390:	8f 5f       	subi	r24, 0xFF	; 255
     392:	80 93 07 01 	sts	0x0107, r24
							}
							if (usb_alive < 3){
     396:	80 91 07 01 	lds	r24, 0x0107
     39a:	83 30       	cpi	r24, 0x03	; 3
     39c:	70 f0       	brcs	.+28     	; 0x3ba <main+0x29e>

							}
							else
							{
								//LED_OFF; //error.. there should be a comunication with the PC software...
								wdt_enable(WDTO_250MS);
     39e:	2c e0       	ldi	r18, 0x0C	; 12
     3a0:	88 e1       	ldi	r24, 0x18	; 24
     3a2:	90 e0       	ldi	r25, 0x00	; 0
     3a4:	0f b6       	in	r0, 0x3f	; 63
     3a6:	f8 94       	cli
     3a8:	a8 95       	wdr
     3aa:	80 93 60 00 	sts	0x0060, r24
     3ae:	0f be       	out	0x3f, r0	; 63
     3b0:	20 93 60 00 	sts	0x0060, r18
								while(1){ 
									LED_OFF
     3b4:	50 9a       	sbi	0x0a, 0	; 10
     3b6:	58 98       	cbi	0x0b, 0	; 11
     3b8:	fd cf       	rjmp	.-6      	; 0x3b4 <main+0x298>
							}
						}else
						{
							//LED_ON;
						}
						if (idle_blink_counter < 160000)
     3ba:	80 91 15 02 	lds	r24, 0x0215
     3be:	90 91 16 02 	lds	r25, 0x0216
     3c2:	a0 91 17 02 	lds	r26, 0x0217
     3c6:	b0 91 18 02 	lds	r27, 0x0218
     3ca:	80 50       	subi	r24, 0x00	; 0
     3cc:	91 47       	sbci	r25, 0x71	; 113
     3ce:	a2 40       	sbci	r26, 0x02	; 2
     3d0:	b0 40       	sbci	r27, 0x00	; 0
     3d2:	18 f4       	brcc	.+6      	; 0x3da <main+0x2be>
						{
								LED_ON;
     3d4:	50 9a       	sbi	0x0a, 0	; 10
     3d6:	58 9a       	sbi	0x0b, 0	; 11
     3d8:	02 c0       	rjmp	.+4      	; 0x3de <main+0x2c2>
						}else
						{
							LED_OFF;
     3da:	50 9a       	sbi	0x0a, 0	; 10
     3dc:	58 98       	cbi	0x0b, 0	; 11
						}
					}
				break;
			}
	 		
			switch(state_machine)
     3de:	80 91 23 01 	lds	r24, 0x0123
     3e2:	86 30       	cpi	r24, 0x06	; 6
     3e4:	09 f4       	brne	.+2      	; 0x3e8 <main+0x2cc>
     3e6:	53 c0       	rjmp	.+166    	; 0x48e <main+0x372>
     3e8:	87 30       	cpi	r24, 0x07	; 7
     3ea:	60 f4       	brcc	.+24     	; 0x404 <main+0x2e8>
     3ec:	81 30       	cpi	r24, 0x01	; 1
     3ee:	09 f4       	brne	.+2      	; 0x3f2 <main+0x2d6>
     3f0:	7d c0       	rjmp	.+250    	; 0x4ec <main+0x3d0>
     3f2:	81 30       	cpi	r24, 0x01	; 1
     3f4:	b0 f0       	brcs	.+44     	; 0x422 <main+0x306>
     3f6:	82 30       	cpi	r24, 0x02	; 2
     3f8:	09 f4       	brne	.+2      	; 0x3fc <main+0x2e0>
     3fa:	91 c2       	rjmp	.+1314   	; 0x91e <__stack+0x41f>
     3fc:	83 30       	cpi	r24, 0x03	; 3
     3fe:	09 f0       	breq	.+2      	; 0x402 <main+0x2e6>
     400:	70 cf       	rjmp	.-288    	; 0x2e2 <main+0x1c6>
     402:	13 c4       	rjmp	.+2086   	; 0xc2a <__stack+0x72b>
     404:	8a 30       	cpi	r24, 0x0A	; 10
     406:	81 f0       	breq	.+32     	; 0x428 <main+0x30c>
     408:	8b 30       	cpi	r24, 0x0B	; 11
     40a:	20 f4       	brcc	.+8      	; 0x414 <main+0x2f8>
     40c:	87 30       	cpi	r24, 0x07	; 7
     40e:	09 f0       	breq	.+2      	; 0x412 <main+0x2f6>
     410:	68 cf       	rjmp	.-304    	; 0x2e2 <main+0x1c6>
     412:	ae c4       	rjmp	.+2396   	; 0xd70 <__stack+0x871>
     414:	82 36       	cpi	r24, 0x62	; 98
     416:	09 f4       	brne	.+2      	; 0x41a <main+0x2fe>
     418:	d4 c4       	rjmp	.+2472   	; 0xdc2 <__stack+0x8c3>
     41a:	83 36       	cpi	r24, 0x63	; 99
     41c:	09 f0       	breq	.+2      	; 0x420 <main+0x304>
     41e:	61 cf       	rjmp	.-318    	; 0x2e2 <main+0x1c6>
     420:	ec c4       	rjmp	.+2520   	; 0xdfa <__stack+0x8fb>
			{
				case 0: //IDLE
					//gen_mode = 0; 
					trigged = 0;
     422:	10 92 13 02 	sts	0x0213, r1
     426:	5d cf       	rjmp	.-326    	; 0x2e2 <main+0x1c6>
				break;
				case USB_GET_SN:
					stream[1] = my_sn[0];
     428:	80 91 1a 01 	lds	r24, 0x011A
     42c:	80 93 26 01 	sts	0x0126, r24
					stream[2] = my_sn[1];
     430:	80 91 1b 01 	lds	r24, 0x011B
     434:	80 93 27 01 	sts	0x0127, r24
					stream[3] = my_sn[2];
     438:	80 91 1c 01 	lds	r24, 0x011C
     43c:	80 93 28 01 	sts	0x0128, r24
					stream[4] = my_sn[3];
     440:	80 91 1d 01 	lds	r24, 0x011D
     444:	80 93 29 01 	sts	0x0129, r24
					stream[5] = FWV_MAJ;
     448:	50 92 2a 01 	sts	0x012A, r5
					stream[6] = FWV_MIN;
     44c:	83 e0       	ldi	r24, 0x03	; 3
     44e:	80 93 2b 01 	sts	0x012B, r24
					//LED_ON;
					if (usb_data_read == 1) //make sure previous data have been read by HOST
     452:	80 91 04 01 	lds	r24, 0x0104
     456:	81 30       	cpi	r24, 0x01	; 1
     458:	09 f0       	breq	.+2      	; 0x45c <main+0x340>
     45a:	43 cf       	rjmp	.-378    	; 0x2e2 <main+0x1c6>
						{
							//LED_OFF;
							memset((void*)stream,0,128);
     45c:	84 2d       	mov	r24, r4
     45e:	98 85       	ldd	r25, Y+8	; 0x08
     460:	60 e0       	ldi	r22, 0x00	; 0
     462:	70 e0       	ldi	r23, 0x00	; 0
     464:	40 e8       	ldi	r20, 0x80	; 128
     466:	50 e0       	ldi	r21, 0x00	; 0
     468:	0e 94 2c 0b 	call	0x1658	; 0x1658 <memset>
							state_machine=0; //IDLE STATE
     46c:	10 92 23 01 	sts	0x0123, r1
							stream[1] = 99;	//Tell PC i finished sending data, and/or currently IDLE
     470:	93 e6       	ldi	r25, 0x63	; 99
     472:	90 93 26 01 	sts	0x0126, r25
							stream[0] = USB_FEEDBACK;
     476:	25 e0       	ldi	r18, 0x05	; 5
     478:	20 93 25 01 	sts	0x0125, r18
							stream[2] = 0;
     47c:	10 92 27 01 	sts	0x0127, r1
							stream[3] = 0;
     480:	10 92 28 01 	sts	0x0128, r1
							stream[4] = 0;
     484:	10 92 29 01 	sts	0x0129, r1
							usb_data_read = 0;
     488:	10 92 04 01 	sts	0x0104, r1
     48c:	2a cf       	rjmp	.-428    	; 0x2e2 <main+0x1c6>
							
						}
						
				break;
				case 6: //fast read mode (for live update on PC end), to exit this mode, PC have to send ABORT (0x2)
					usb_data_read = 0;
     48e:	10 92 04 01 	sts	0x0104, r1
					ISOLATE_ATMEGA //set MOSI lines as input
     492:	87 b1       	in	r24, 0x07	; 7
     494:	80 7f       	andi	r24, 0xF0	; 240
     496:	87 b9       	out	0x07, r24	; 7
					//all IN
					SET_CH12_IN
     498:	21 9a       	sbi	0x04, 1	; 4
     49a:	29 98       	cbi	0x05, 1	; 5
     49c:	22 9a       	sbi	0x04, 2	; 4
     49e:	2a 9a       	sbi	0x05, 2	; 5
					SET_CH34_IN
     4a0:	20 9a       	sbi	0x04, 0	; 4
     4a2:	28 98       	cbi	0x05, 0	; 5
     4a4:	24 9a       	sbi	0x04, 4	; 4
     4a6:	2c 9a       	sbi	0x05, 4	; 5

					//stream[0] = 199;
					stream[1] = (PIN_MOSI & (1<<MOSI0))>>MOSI0;
     4a8:	86 b1       	in	r24, 0x06	; 6
     4aa:	81 70       	andi	r24, 0x01	; 1
     4ac:	80 93 26 01 	sts	0x0126, r24
					stream[2] = (PIN_MOSI & (1<<MOSI1))>>MOSI1;
     4b0:	86 b1       	in	r24, 0x06	; 6
     4b2:	90 e0       	ldi	r25, 0x00	; 0
     4b4:	82 70       	andi	r24, 0x02	; 2
     4b6:	90 70       	andi	r25, 0x00	; 0
     4b8:	95 95       	asr	r25
     4ba:	87 95       	ror	r24
     4bc:	80 93 27 01 	sts	0x0127, r24
					stream[3] = (PIN_MOSI & (1<<MOSI2))>>MOSI2;
     4c0:	86 b1       	in	r24, 0x06	; 6
     4c2:	90 e0       	ldi	r25, 0x00	; 0
     4c4:	84 70       	andi	r24, 0x04	; 4
     4c6:	90 70       	andi	r25, 0x00	; 0
     4c8:	95 95       	asr	r25
     4ca:	87 95       	ror	r24
     4cc:	95 95       	asr	r25
     4ce:	87 95       	ror	r24
     4d0:	80 93 28 01 	sts	0x0128, r24
					stream[4] = (PIN_MOSI & (1<<MOSI3))>>MOSI3;
     4d4:	86 b1       	in	r24, 0x06	; 6
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	88 70       	andi	r24, 0x08	; 8
     4da:	90 70       	andi	r25, 0x00	; 0
     4dc:	e3 e0       	ldi	r30, 0x03	; 3
     4de:	95 95       	asr	r25
     4e0:	87 95       	ror	r24
     4e2:	ea 95       	dec	r30
     4e4:	e1 f7       	brne	.-8      	; 0x4de <main+0x3c2>
     4e6:	80 93 29 01 	sts	0x0129, r24
     4ea:	fb ce       	rjmp	.-522    	; 0x2e2 <main+0x1c6>
				break;
				case 1: //Setting up sequence
					LED_OFF;
     4ec:	50 9a       	sbi	0x0a, 0	; 10
     4ee:	58 98       	cbi	0x0b, 0	; 11


					//Re initialise the SRAMs
					sram_write_status((1<<0)|(1<<6)); //Set sequencial read/write mode
     4f0:	81 e4       	ldi	r24, 0x41	; 65
     4f2:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <sram_write_status>
					DDR_CLK_ENA |= CLK_ENA; //Set CLK_ENA as output
     4f6:	27 9a       	sbi	0x04, 7	; 4
					DDR_MISO &= ~(MISO_MASK); //set MOSI pins as inputs
     4f8:	8a b1       	in	r24, 0x0a	; 10
     4fa:	87 78       	andi	r24, 0x87	; 135
     4fc:	8a b9       	out	0x0a, r24	; 10
					DDR_CLK |= CLK;				//set pin as output
     4fe:	23 9a       	sbi	0x04, 3	; 4
     500:	80 e5       	ldi	r24, 0x50	; 80
     502:	93 ec       	ldi	r25, 0xC3	; 195
     504:	01 97       	sbiw	r24, 0x01	; 1
     506:	f1 f7       	brne	.-4      	; 0x504 <__stack+0x5>
					_delay_ms(10);	
					SRAM_HS_CLK_DIS;
     508:	2f 9a       	sbi	0x05, 7	; 5
     50a:	23 9a       	sbi	0x04, 3	; 4
     50c:	2b 98       	cbi	0x05, 3	; 5


					//Start a new sequence
					sampling_done = 0;
     50e:	10 92 12 02 	sts	0x0212, r1
					abort_sequence = 0;
     512:	10 92 1e 01 	sts	0x011E, r1
					PCMSK1 = 0x0;
     516:	10 92 6c 00 	sts	0x006C, r1
					PCIFR = 0xFF;
     51a:	8f ef       	ldi	r24, 0xFF	; 255
     51c:	8b bb       	out	0x1b, r24	; 27
					_delay_us(5);
					SET_CH12_IN
					SET_CH34_IN
					*/

					ISOLATE_PROBES;
     51e:	21 9a       	sbi	0x04, 1	; 4
     520:	29 9a       	sbi	0x05, 1	; 5
     522:	20 9a       	sbi	0x04, 0	; 4
     524:	28 9a       	sbi	0x05, 0	; 5
     526:	22 9a       	sbi	0x04, 2	; 4
     528:	2a 9a       	sbi	0x05, 2	; 5
     52a:	24 9a       	sbi	0x04, 4	; 4
     52c:	2c 9a       	sbi	0x05, 4	; 5
					
					//*** clear SRAM content
					switch(stream[1])
     52e:	80 91 26 01 	lds	r24, 0x0126
     532:	82 30       	cpi	r24, 0x02	; 2
     534:	d1 f0       	breq	.+52     	; 0x56a <__stack+0x6b>
     536:	83 30       	cpi	r24, 0x03	; 3
     538:	89 f1       	breq	.+98     	; 0x59c <__stack+0x9d>
     53a:	88 23       	and	r24, r24
     53c:	09 f0       	breq	.+2      	; 0x540 <__stack+0x41>
     53e:	49 c0       	rjmp	.+146    	; 0x5d2 <__stack+0xd3>
					{
						case 0: //all in, write to SRAM
							//clear  all SRAMS
							sram_mixed_setup(INST_WRITE, INST_WRITE, 0);
     540:	82 e0       	ldi	r24, 0x02	; 2
     542:	62 e0       	ldi	r22, 0x02	; 2
     544:	40 e0       	ldi	r20, 0x00	; 0
     546:	50 e0       	ldi	r21, 0x00	; 0
     548:	0e 94 65 1d 	call	0x3aca	; 0x3aca <sram_mixed_setup>
							sram_out(0,CH_ALL);
     54c:	80 e0       	ldi	r24, 0x00	; 0
     54e:	63 e6       	ldi	r22, 0x63	; 99
     550:	0e 94 00 1c 	call	0x3800	; 0x3800 <sram_out>
							SRAM_HS_CLK_ENA
     554:	2f 98       	cbi	0x05, 7	; 5
     556:	23 9a       	sbi	0x04, 3	; 4
     558:	2b 9a       	sbi	0x05, 3	; 5
     55a:	84 ec       	ldi	r24, 0xC4	; 196
     55c:	99 e0       	ldi	r25, 0x09	; 9
     55e:	f1 01       	movw	r30, r2
     560:	31 97       	sbiw	r30, 0x01	; 1
     562:	f1 f7       	brne	.-4      	; 0x560 <__stack+0x61>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     564:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     566:	d9 f7       	brne	.-10     	; 0x55e <__stack+0x5f>
     568:	31 c0       	rjmp	.+98     	; 0x5cc <__stack+0xcd>
						break;
						case 1://all output, read from SRAM
							//don't clear anything, in case playback is needed
						break;
						case 2://1,2 OUT, 
							sram_mixed_setup(INST_READ, INST_WRITE, 0);
     56a:	83 e0       	ldi	r24, 0x03	; 3
     56c:	62 e0       	ldi	r22, 0x02	; 2
     56e:	40 e0       	ldi	r20, 0x00	; 0
     570:	50 e0       	ldi	r21, 0x00	; 0
     572:	0e 94 65 1d 	call	0x3aca	; 0x3aca <sram_mixed_setup>
							sram_out(0,2);
     576:	80 e0       	ldi	r24, 0x00	; 0
     578:	62 e0       	ldi	r22, 0x02	; 2
     57a:	0e 94 00 1c 	call	0x3800	; 0x3800 <sram_out>
							sram_out(0,3);
     57e:	80 e0       	ldi	r24, 0x00	; 0
     580:	63 e0       	ldi	r22, 0x03	; 3
     582:	0e 94 00 1c 	call	0x3800	; 0x3800 <sram_out>
							SRAM_HS_CLK_ENA
     586:	2f 98       	cbi	0x05, 7	; 5
     588:	23 9a       	sbi	0x04, 3	; 4
     58a:	2b 9a       	sbi	0x05, 3	; 5
     58c:	84 ec       	ldi	r24, 0xC4	; 196
     58e:	99 e0       	ldi	r25, 0x09	; 9
     590:	f1 01       	movw	r30, r2
     592:	31 97       	sbiw	r30, 0x01	; 1
     594:	f1 f7       	brne	.-4      	; 0x592 <__stack+0x93>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     596:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     598:	d9 f7       	brne	.-10     	; 0x590 <__stack+0x91>
     59a:	18 c0       	rjmp	.+48     	; 0x5cc <__stack+0xcd>
					    _delay_ms(250);
							SRAM_HS_CLK_DIS;
						break;
						case 3://3,4 out
							sram_mixed_setup(INST_WRITE, INST_READ, 0);
     59c:	82 e0       	ldi	r24, 0x02	; 2
     59e:	63 e0       	ldi	r22, 0x03	; 3
     5a0:	40 e0       	ldi	r20, 0x00	; 0
     5a2:	50 e0       	ldi	r21, 0x00	; 0
     5a4:	0e 94 65 1d 	call	0x3aca	; 0x3aca <sram_mixed_setup>
							sram_out(0,0);
     5a8:	80 e0       	ldi	r24, 0x00	; 0
     5aa:	60 e0       	ldi	r22, 0x00	; 0
     5ac:	0e 94 00 1c 	call	0x3800	; 0x3800 <sram_out>
							sram_out(0,1);
     5b0:	80 e0       	ldi	r24, 0x00	; 0
     5b2:	61 e0       	ldi	r22, 0x01	; 1
     5b4:	0e 94 00 1c 	call	0x3800	; 0x3800 <sram_out>
							SRAM_HS_CLK_ENA
     5b8:	2f 98       	cbi	0x05, 7	; 5
     5ba:	23 9a       	sbi	0x04, 3	; 4
     5bc:	2b 9a       	sbi	0x05, 3	; 5
     5be:	84 ec       	ldi	r24, 0xC4	; 196
     5c0:	99 e0       	ldi	r25, 0x09	; 9
     5c2:	f1 01       	movw	r30, r2
     5c4:	31 97       	sbiw	r30, 0x01	; 1
     5c6:	f1 f7       	brne	.-4      	; 0x5c4 <__stack+0xc5>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     5c8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     5ca:	d9 f7       	brne	.-10     	; 0x5c2 <__stack+0xc3>
					    _delay_ms(250);
							SRAM_HS_CLK_DIS;
     5cc:	2f 9a       	sbi	0x05, 7	; 5
     5ce:	23 9a       	sbi	0x04, 3	; 4
     5d0:	2b 98       	cbi	0x05, 3	; 5
						


					//***** end of clear SRAM content

					sram_cs_end(); //Stop the SRAM sequence in case it was still active					
     5d2:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <sram_cs_end>

					//read number of samples to store before trigger
					memcpy((void*)(&pre_trigger_samples), (void*)(&stream[2]),2);
     5d6:	80 91 27 01 	lds	r24, 0x0127
     5da:	90 91 28 01 	lds	r25, 0x0128
     5de:	90 93 0a 02 	sts	0x020A, r25
     5e2:	80 93 09 02 	sts	0x0209, r24
					pre_trigger_samples = pre_trigger_samples * 8;
     5e6:	80 91 09 02 	lds	r24, 0x0209
     5ea:	90 91 0a 02 	lds	r25, 0x020A
     5ee:	a0 91 0b 02 	lds	r26, 0x020B
     5f2:	b0 91 0c 02 	lds	r27, 0x020C
     5f6:	73 e0       	ldi	r23, 0x03	; 3
     5f8:	88 0f       	add	r24, r24
     5fa:	99 1f       	adc	r25, r25
     5fc:	aa 1f       	adc	r26, r26
     5fe:	bb 1f       	adc	r27, r27
     600:	7a 95       	dec	r23
     602:	d1 f7       	brne	.-12     	; 0x5f8 <__stack+0xf9>
     604:	80 93 09 02 	sts	0x0209, r24
     608:	90 93 0a 02 	sts	0x020A, r25
     60c:	a0 93 0b 02 	sts	0x020B, r26
     610:	b0 93 0c 02 	sts	0x020C, r27
					//pre_trigger_samples = 50;

					//read number of samples to store after trigger
					memcpy((void*)(&post_trigger_samples), (void*)(&stream[4]),2);
     614:	80 91 29 01 	lds	r24, 0x0129
     618:	90 91 2a 01 	lds	r25, 0x012A
     61c:	90 93 20 01 	sts	0x0120, r25
     620:	80 93 1f 01 	sts	0x011F, r24
					post_trigger_samples = post_trigger_samples * 8;
     624:	80 91 1f 01 	lds	r24, 0x011F
     628:	90 91 20 01 	lds	r25, 0x0120
     62c:	a0 91 21 01 	lds	r26, 0x0121
     630:	b0 91 22 01 	lds	r27, 0x0122
     634:	63 e0       	ldi	r22, 0x03	; 3
     636:	88 0f       	add	r24, r24
     638:	99 1f       	adc	r25, r25
     63a:	aa 1f       	adc	r26, r26
     63c:	bb 1f       	adc	r27, r27
     63e:	6a 95       	dec	r22
     640:	d1 f7       	brne	.-12     	; 0x636 <__stack+0x137>
     642:	80 93 1f 01 	sts	0x011F, r24
     646:	90 93 20 01 	sts	0x0120, r25
     64a:	a0 93 21 01 	sts	0x0121, r26
     64e:	b0 93 22 01 	sts	0x0122, r27

					
					//Setup data direction
					switch(stream[1])
     652:	00 91 26 01 	lds	r16, 0x0126
     656:	01 30       	cpi	r16, 0x01	; 1
     658:	71 f0       	breq	.+28     	; 0x676 <__stack+0x177>
     65a:	01 30       	cpi	r16, 0x01	; 1
     65c:	28 f0       	brcs	.+10     	; 0x668 <__stack+0x169>
     65e:	02 30       	cpi	r16, 0x02	; 2
     660:	a9 f0       	breq	.+42     	; 0x68c <__stack+0x18d>
     662:	03 30       	cpi	r16, 0x03	; 3
     664:	01 f5       	brne	.+64     	; 0x6a6 <__stack+0x1a7>
     666:	15 c0       	rjmp	.+42     	; 0x692 <__stack+0x193>
					{
						case 0: //all in, write to SRAM
							sram_mixed_setup(INST_WRITE, INST_WRITE, 0);
     668:	82 e0       	ldi	r24, 0x02	; 2
     66a:	62 e0       	ldi	r22, 0x02	; 2
     66c:	40 e0       	ldi	r20, 0x00	; 0
     66e:	50 e0       	ldi	r21, 0x00	; 0
     670:	0e 94 65 1d 	call	0x3aca	; 0x3aca <sram_mixed_setup>
     674:	16 c0       	rjmp	.+44     	; 0x6a2 <__stack+0x1a3>
							gen_mode = 0;
						break;
						case 1://all output, read from SRAM
							sram_mixed_setup(INST_READ, INST_READ, 0);
     676:	83 e0       	ldi	r24, 0x03	; 3
     678:	63 e0       	ldi	r22, 0x03	; 3
     67a:	40 e0       	ldi	r20, 0x00	; 0
     67c:	50 e0       	ldi	r21, 0x00	; 0
     67e:	0e 94 65 1d 	call	0x3aca	; 0x3aca <sram_mixed_setup>
							LED_ON;
     682:	50 9a       	sbi	0x0a, 0	; 10
     684:	58 9a       	sbi	0x0b, 0	; 11
							gen_mode = 1;
     686:	00 93 17 01 	sts	0x0117, r16
     68a:	0d c0       	rjmp	.+26     	; 0x6a6 <__stack+0x1a7>
						break;
						case 2://1,2 OUT, 
							sram_mixed_setup(INST_READ, INST_WRITE, 0);
     68c:	83 e0       	ldi	r24, 0x03	; 3
     68e:	62 e0       	ldi	r22, 0x02	; 2
     690:	02 c0       	rjmp	.+4      	; 0x696 <__stack+0x197>
							LED_ON;
							gen_mode = 0;
						break;
						case 3://3,4 out
							sram_mixed_setup(INST_WRITE, INST_READ, 0);
     692:	82 e0       	ldi	r24, 0x02	; 2
     694:	63 e0       	ldi	r22, 0x03	; 3
     696:	40 e0       	ldi	r20, 0x00	; 0
     698:	50 e0       	ldi	r21, 0x00	; 0
     69a:	0e 94 65 1d 	call	0x3aca	; 0x3aca <sram_mixed_setup>
							LED_ON;
     69e:	50 9a       	sbi	0x0a, 0	; 10
     6a0:	58 9a       	sbi	0x0b, 0	; 11
							gen_mode = 0;
     6a2:	10 92 17 01 	sts	0x0117, r1
						break;
						default:
						break;
					}
					SRAM_HS_CLK_DIS;
     6a6:	2f 9a       	sbi	0x05, 7	; 5
     6a8:	23 9a       	sbi	0x04, 3	; 4
     6aa:	2b 98       	cbi	0x05, 3	; 5
					ISOLATE_ATMEGA //Isolate MOSI line of the atmega, set all to inputs, no need to send anymore instructions to SRAMS
     6ac:	87 b1       	in	r24, 0x07	; 7
     6ae:	80 7f       	andi	r24, 0xF0	; 240
     6b0:	87 b9       	out	0x07, r24	; 7
				
					//Activate buffers
					switch(stream[1])
     6b2:	80 91 26 01 	lds	r24, 0x0126
     6b6:	81 30       	cpi	r24, 0x01	; 1
     6b8:	61 f0       	breq	.+24     	; 0x6d2 <__stack+0x1d3>
     6ba:	81 30       	cpi	r24, 0x01	; 1
     6bc:	28 f0       	brcs	.+10     	; 0x6c8 <__stack+0x1c9>
     6be:	82 30       	cpi	r24, 0x02	; 2
     6c0:	69 f0       	breq	.+26     	; 0x6dc <__stack+0x1dd>
     6c2:	83 30       	cpi	r24, 0x03	; 3
     6c4:	e1 f4       	brne	.+56     	; 0x6fe <__stack+0x1ff>
     6c6:	13 c0       	rjmp	.+38     	; 0x6ee <__stack+0x1ef>
					{
						case 0: //all IN
							SET_CH12_IN
     6c8:	21 9a       	sbi	0x04, 1	; 4
     6ca:	29 98       	cbi	0x05, 1	; 5
     6cc:	22 9a       	sbi	0x04, 2	; 4
     6ce:	2a 9a       	sbi	0x05, 2	; 5
     6d0:	09 c0       	rjmp	.+18     	; 0x6e4 <__stack+0x1e5>
							SET_CH34_IN
						break;
						case 1://all OUT
							SET_CH12_OUT
     6d2:	21 9a       	sbi	0x04, 1	; 4
     6d4:	29 9a       	sbi	0x05, 1	; 5
     6d6:	22 9a       	sbi	0x04, 2	; 4
     6d8:	2a 98       	cbi	0x05, 2	; 5
     6da:	0d c0       	rjmp	.+26     	; 0x6f6 <__stack+0x1f7>
							SET_CH34_OUT
						break;
						case 2://1,2 OUT
							SET_CH12_OUT
     6dc:	21 9a       	sbi	0x04, 1	; 4
     6de:	29 9a       	sbi	0x05, 1	; 5
     6e0:	22 9a       	sbi	0x04, 2	; 4
     6e2:	2a 98       	cbi	0x05, 2	; 5
							SET_CH34_IN
     6e4:	20 9a       	sbi	0x04, 0	; 4
     6e6:	28 98       	cbi	0x05, 0	; 5
     6e8:	24 9a       	sbi	0x04, 4	; 4
     6ea:	2c 9a       	sbi	0x05, 4	; 5
     6ec:	08 c0       	rjmp	.+16     	; 0x6fe <__stack+0x1ff>
						break;
						case 3://3,4 out
							SET_CH12_IN
     6ee:	21 9a       	sbi	0x04, 1	; 4
     6f0:	29 98       	cbi	0x05, 1	; 5
     6f2:	22 9a       	sbi	0x04, 2	; 4
     6f4:	2a 9a       	sbi	0x05, 2	; 5
							SET_CH34_OUT
     6f6:	20 9a       	sbi	0x04, 0	; 4
     6f8:	28 9a       	sbi	0x05, 0	; 5
     6fa:	24 9a       	sbi	0x04, 4	; 4
     6fc:	2c 98       	cbi	0x05, 4	; 5
						default:
						break;
					}
				
					//Set trigger type
					trigger_type = stream[7];
     6fe:	80 91 2c 01 	lds	r24, 0x012C
     702:	80 93 03 01 	sts	0x0103, r24
				
					trigger_channel = stream[8];
     706:	80 91 2d 01 	lds	r24, 0x012D
     70a:	80 93 14 01 	sts	0x0114, r24
					//Set trigger channel
					if (trigger_type != TRIG_NULL)
     70e:	80 91 03 01 	lds	r24, 0x0103
     712:	83 30       	cpi	r24, 0x03	; 3
     714:	b9 f0       	breq	.+46     	; 0x744 <__stack+0x245>
					{
						PCICR = (1<<PCIE1);
     716:	82 e0       	ldi	r24, 0x02	; 2
     718:	80 93 68 00 	sts	0x0068, r24
						switch(stream[8])
     71c:	80 91 2d 01 	lds	r24, 0x012D
     720:	88 23       	and	r24, r24
     722:	11 f4       	brne	.+4      	; 0x728 <__stack+0x229>
						{
							case 0: //any channel can cause trigger
								PCMSK1 = 0xF;
     724:	8f e0       	ldi	r24, 0x0F	; 15
     726:	0c c0       	rjmp	.+24     	; 0x740 <__stack+0x241>
							break;
							default: //single channel tigger
								PCMSK1 = (1<< (stream[8] -1));
     728:	20 91 2d 01 	lds	r18, 0x012D
     72c:	30 e0       	ldi	r19, 0x00	; 0
     72e:	21 50       	subi	r18, 0x01	; 1
     730:	30 40       	sbci	r19, 0x00	; 0
     732:	81 e0       	ldi	r24, 0x01	; 1
     734:	90 e0       	ldi	r25, 0x00	; 0
     736:	02 c0       	rjmp	.+4      	; 0x73c <__stack+0x23d>
     738:	88 0f       	add	r24, r24
     73a:	99 1f       	adc	r25, r25
     73c:	2a 95       	dec	r18
     73e:	e2 f7       	brpl	.-8      	; 0x738 <__stack+0x239>
     740:	80 93 6c 00 	sts	0x006C, r24
							break;
						}
					}

					stream[135] = 0; //JFT***********
     744:	10 92 ac 01 	sts	0x01AC, r1

					memcpy((void*)(&stream[133]), (void*)(&stream[10]),2); //copy the trigger count or delay value
     748:	80 91 2f 01 	lds	r24, 0x012F
     74c:	90 91 30 01 	lds	r25, 0x0130
     750:	90 93 ab 01 	sts	0x01AB, r25
     754:	80 93 aa 01 	sts	0x01AA, r24


					//Reset timer 1
					TCNT1 = 0; timer1_post_scaller = 0;
     758:	10 92 85 00 	sts	0x0085, r1
     75c:	10 92 84 00 	sts	0x0084, r1
     760:	10 92 1a 02 	sts	0x021A, r1
     764:	10 92 19 02 	sts	0x0219, r1
				
					// Start sampling clock, can be internal or external high speed clock.
					switch(stream[6])
     768:	20 91 2b 01 	lds	r18, 0x012B
     76c:	25 30       	cpi	r18, 0x05	; 5
     76e:	09 f4       	brne	.+2      	; 0x772 <__stack+0x273>
     770:	5a c0       	rjmp	.+180    	; 0x826 <__stack+0x327>
     772:	26 30       	cpi	r18, 0x06	; 6
     774:	80 f4       	brcc	.+32     	; 0x796 <__stack+0x297>
     776:	22 30       	cpi	r18, 0x02	; 2
     778:	d1 f1       	breq	.+116    	; 0x7ee <__stack+0x2ef>
     77a:	23 30       	cpi	r18, 0x03	; 3
     77c:	30 f4       	brcc	.+12     	; 0x78a <__stack+0x28b>
     77e:	22 23       	and	r18, r18
     780:	e9 f0       	breq	.+58     	; 0x7bc <__stack+0x2bd>
     782:	21 30       	cpi	r18, 0x01	; 1
     784:	09 f0       	breq	.+2      	; 0x788 <__stack+0x289>
     786:	8d c0       	rjmp	.+282    	; 0x8a2 <__stack+0x3a3>
     788:	23 c0       	rjmp	.+70     	; 0x7d0 <__stack+0x2d1>
     78a:	23 30       	cpi	r18, 0x03	; 3
     78c:	a9 f1       	breq	.+106    	; 0x7f8 <__stack+0x2f9>
     78e:	24 30       	cpi	r18, 0x04	; 4
     790:	09 f0       	breq	.+2      	; 0x794 <__stack+0x295>
     792:	87 c0       	rjmp	.+270    	; 0x8a2 <__stack+0x3a3>
     794:	42 c0       	rjmp	.+132    	; 0x81a <__stack+0x31b>
     796:	28 30       	cpi	r18, 0x08	; 8
     798:	09 f4       	brne	.+2      	; 0x79c <__stack+0x29d>
     79a:	57 c0       	rjmp	.+174    	; 0x84a <__stack+0x34b>
     79c:	29 30       	cpi	r18, 0x09	; 9
     79e:	38 f4       	brcc	.+14     	; 0x7ae <__stack+0x2af>
     7a0:	26 30       	cpi	r18, 0x06	; 6
     7a2:	09 f4       	brne	.+2      	; 0x7a6 <__stack+0x2a7>
     7a4:	46 c0       	rjmp	.+140    	; 0x832 <__stack+0x333>
     7a6:	27 30       	cpi	r18, 0x07	; 7
     7a8:	09 f0       	breq	.+2      	; 0x7ac <__stack+0x2ad>
     7aa:	7b c0       	rjmp	.+246    	; 0x8a2 <__stack+0x3a3>
     7ac:	48 c0       	rjmp	.+144    	; 0x83e <__stack+0x33f>
     7ae:	29 30       	cpi	r18, 0x09	; 9
     7b0:	09 f4       	brne	.+2      	; 0x7b4 <__stack+0x2b5>
     7b2:	51 c0       	rjmp	.+162    	; 0x856 <__stack+0x357>
     7b4:	2a 30       	cpi	r18, 0x0A	; 10
     7b6:	09 f0       	breq	.+2      	; 0x7ba <__stack+0x2bb>
     7b8:	74 c0       	rjmp	.+232    	; 0x8a2 <__stack+0x3a3>
     7ba:	60 c0       	rjmp	.+192    	; 0x87c <__stack+0x37d>
					{
						case SR_20M: 
							sample_length = 1; //sample_length will determine the relation between timer 1 and the actual number of samples
     7bc:	81 e0       	ldi	r24, 0x01	; 1
     7be:	90 e0       	ldi	r25, 0x00	; 0
     7c0:	90 93 0d 01 	sts	0x010D, r25
     7c4:	80 93 0c 01 	sts	0x010C, r24
							SRAM_HS_CLK_ENA
     7c8:	2f 98       	cbi	0x05, 7	; 5
     7ca:	23 9a       	sbi	0x04, 3	; 4
     7cc:	2b 9a       	sbi	0x05, 3	; 5
     7ce:	69 c0       	rjmp	.+210    	; 0x8a2 <__stack+0x3a3>
						break;
						case SR_10M: 
							OCR2A = 0;
     7d0:	10 92 b3 00 	sts	0x00B3, r1
							sample_length =2 ; //sample_length will determine the relation between timer 1 and the actual number of samples
     7d4:	82 e0       	ldi	r24, 0x02	; 2
     7d6:	90 e0       	ldi	r25, 0x00	; 0
     7d8:	90 93 0d 01 	sts	0x010D, r25
     7dc:	80 93 0c 01 	sts	0x010C, r24
							SRAM_HS_CLK_DIS
     7e0:	2f 9a       	sbi	0x05, 7	; 5
     7e2:	23 9a       	sbi	0x04, 3	; 4
     7e4:	2b 98       	cbi	0x05, 3	; 5
							START_TIMER2_DIV1;
     7e6:	82 e4       	ldi	r24, 0x42	; 66
     7e8:	80 93 b0 00 	sts	0x00B0, r24
     7ec:	57 c0       	rjmp	.+174    	; 0x89c <__stack+0x39d>
						break;
						case SR_5M: 
							OCR2A = 1;
     7ee:	50 92 b3 00 	sts	0x00B3, r5
							sample_length =4 ; //sample_length will determine the relation between timer 1 and the actual number of samples
     7f2:	84 e0       	ldi	r24, 0x04	; 4
     7f4:	90 e0       	ldi	r25, 0x00	; 0
     7f6:	04 c0       	rjmp	.+8      	; 0x800 <__stack+0x301>
							SRAM_HS_CLK_DIS
							START_TIMER2_DIV1;
						break;
						case SR_2M5: 
							OCR2A = 3;
     7f8:	20 93 b3 00 	sts	0x00B3, r18
							sample_length =8 ; //sample_length will determine the relation between timer 1 and the actual number of samples
     7fc:	88 e0       	ldi	r24, 0x08	; 8
     7fe:	90 e0       	ldi	r25, 0x00	; 0
     800:	90 93 0d 01 	sts	0x010D, r25
     804:	80 93 0c 01 	sts	0x010C, r24
							SRAM_HS_CLK_DIS
     808:	2f 9a       	sbi	0x05, 7	; 5
     80a:	23 9a       	sbi	0x04, 3	; 4
     80c:	2b 98       	cbi	0x05, 3	; 5
							START_TIMER2_DIV1;
     80e:	82 e4       	ldi	r24, 0x42	; 66
     810:	80 93 b0 00 	sts	0x00B0, r24
     814:	50 92 b1 00 	sts	0x00B1, r5
     818:	43 c0       	rjmp	.+134    	; 0x8a0 <__stack+0x3a1>
						break;
						case SR_1M: 
							OCR2A = 9;
     81a:	89 e0       	ldi	r24, 0x09	; 9
     81c:	80 93 b3 00 	sts	0x00B3, r24
							sample_length =20 ; //sample_length will determine the relation between timer 1 and the actual number of samples
     820:	84 e1       	ldi	r24, 0x14	; 20
     822:	90 e0       	ldi	r25, 0x00	; 0
     824:	ed cf       	rjmp	.-38     	; 0x800 <__stack+0x301>
							SRAM_HS_CLK_DIS
							START_TIMER2_DIV1;
						break;
						case SR_500K: 
							OCR2A = 19;
     826:	93 e1       	ldi	r25, 0x13	; 19
     828:	90 93 b3 00 	sts	0x00B3, r25
							sample_length =40 ; //sample_length will determine the relation between timer 1 and the actual number of samples
     82c:	88 e2       	ldi	r24, 0x28	; 40
     82e:	90 e0       	ldi	r25, 0x00	; 0
     830:	e7 cf       	rjmp	.-50     	; 0x800 <__stack+0x301>
							SRAM_HS_CLK_DIS
							START_TIMER2_DIV1;
						break;
						case SR_250K: 
							OCR2A = 39;
     832:	87 e2       	ldi	r24, 0x27	; 39
     834:	80 93 b3 00 	sts	0x00B3, r24
							sample_length =80 ; //sample_length will determine the relation between timer 1 and the actual number of samples
     838:	80 e5       	ldi	r24, 0x50	; 80
     83a:	90 e0       	ldi	r25, 0x00	; 0
     83c:	e1 cf       	rjmp	.-62     	; 0x800 <__stack+0x301>
							SRAM_HS_CLK_DIS
							START_TIMER2_DIV1;
						break;
						case SR_100K: 
							OCR2A = 99;
     83e:	93 e6       	ldi	r25, 0x63	; 99
     840:	90 93 b3 00 	sts	0x00B3, r25
							sample_length =200 ; //sample_length will determine the relation between timer 1 and the actual number of samples
     844:	88 ec       	ldi	r24, 0xC8	; 200
     846:	90 e0       	ldi	r25, 0x00	; 0
     848:	db cf       	rjmp	.-74     	; 0x800 <__stack+0x301>
							SRAM_HS_CLK_DIS
							START_TIMER2_DIV1;
						break;
						case SR_50K: 
							OCR2A = 199;
     84a:	87 ec       	ldi	r24, 0xC7	; 199
     84c:	80 93 b3 00 	sts	0x00B3, r24
							sample_length =400 ; //sample_length will determine the relation between timer 1 and the actual number of samples
     850:	80 e9       	ldi	r24, 0x90	; 144
     852:	91 e0       	ldi	r25, 0x01	; 1
     854:	d5 cf       	rjmp	.-86     	; 0x800 <__stack+0x301>
							SRAM_HS_CLK_DIS
							START_TIMER2_DIV1;
						break;
						case SR_10K: 
							OCR2A = 124;
     856:	8c e7       	ldi	r24, 0x7C	; 124
     858:	80 93 b3 00 	sts	0x00B3, r24
							sample_length =2000 ; //sample_length will determine the relation between timer 1 and the actual number of samples
     85c:	80 ed       	ldi	r24, 0xD0	; 208
     85e:	97 e0       	ldi	r25, 0x07	; 7
     860:	90 93 0d 01 	sts	0x010D, r25
     864:	80 93 0c 01 	sts	0x010C, r24
							SRAM_HS_CLK_DIS
     868:	2f 9a       	sbi	0x05, 7	; 5
     86a:	23 9a       	sbi	0x04, 3	; 4
     86c:	2b 98       	cbi	0x05, 3	; 5
							START_TIMER2_DIV8;
     86e:	82 e4       	ldi	r24, 0x42	; 66
     870:	80 93 b0 00 	sts	0x00B0, r24
     874:	82 e0       	ldi	r24, 0x02	; 2
     876:	80 93 b1 00 	sts	0x00B1, r24
     87a:	12 c0       	rjmp	.+36     	; 0x8a0 <__stack+0x3a1>
						break;
						case SR_1K25: 
							OCR2A = 249;
     87c:	89 ef       	ldi	r24, 0xF9	; 249
     87e:	80 93 b3 00 	sts	0x00B3, r24
							sample_length =16000 ; //sample_length will determine the relation between timer 1 and the actual number of samples
     882:	80 e8       	ldi	r24, 0x80	; 128
     884:	9e e3       	ldi	r25, 0x3E	; 62
     886:	90 93 0d 01 	sts	0x010D, r25
     88a:	80 93 0c 01 	sts	0x010C, r24
							SRAM_HS_CLK_DIS
     88e:	2f 9a       	sbi	0x05, 7	; 5
     890:	23 9a       	sbi	0x04, 3	; 4
     892:	2b 98       	cbi	0x05, 3	; 5
							START_TIMER2_DIV32;
     894:	82 e4       	ldi	r24, 0x42	; 66
     896:	80 93 b0 00 	sts	0x00B0, r24
     89a:	23 e0       	ldi	r18, 0x03	; 3
     89c:	20 93 b1 00 	sts	0x00B1, r18
     8a0:	23 9a       	sbi	0x04, 3	; 4
						default:
						break;
					}


					if (gen_mode == 1) 
     8a2:	80 91 17 01 	lds	r24, 0x0117
     8a6:	81 30       	cpi	r24, 0x01	; 1
     8a8:	49 f4       	brne	.+18     	; 0x8bc <__stack+0x3bd>
					{
						state_machine=0; //IDLE STATE
     8aa:	10 92 23 01 	sts	0x0123, r1
						stream[1] = 99;	//Tell PC i finished sending data, and/or currently IDLE
     8ae:	83 e6       	ldi	r24, 0x63	; 99
     8b0:	80 93 26 01 	sts	0x0126, r24
						stream[0] = USB_FEEDBACK;
     8b4:	95 e0       	ldi	r25, 0x05	; 5
     8b6:	90 93 25 01 	sts	0x0125, r25
     8ba:	13 cd       	rjmp	.-1498   	; 0x2e2 <main+0x1c6>
					}
					else
					{
						//Start Timer 1
						START_TIMER1;						
     8bc:	50 92 81 00 	sts	0x0081, r5

						
						//
						//sample_length *= 2;
						min_valid_signal_period = sample_length*5; //used to reject noise for the trigger detection
     8c0:	80 91 0c 01 	lds	r24, 0x010C
     8c4:	90 91 0d 01 	lds	r25, 0x010D
     8c8:	9c 01       	movw	r18, r24
     8ca:	22 0f       	add	r18, r18
     8cc:	33 1f       	adc	r19, r19
     8ce:	22 0f       	add	r18, r18
     8d0:	33 1f       	adc	r19, r19
     8d2:	28 0f       	add	r18, r24
     8d4:	39 1f       	adc	r19, r25
     8d6:	20 93 1b 02 	sts	0x021B, r18
						// to do : take care of always being able to exit sampling using the "cancel sequence" command via USB, even when 
						//					scanalogic is waiting for trigger, we have to disable PinChange interrupt and, if we are in the post-trigger loop, exit that loop.
						//				The best way to do that is to add a variable called "stop_sampling", and in timer0 interrupt (that does usb pool, it also checks for
						//				USB stop command, and sets "stop_sampling = 1". in the post sampling pooling loop, add a condition to exit that loop in case "stop_sampling = 1"

						if (trigger_type == TRIG_NULL)
     8da:	80 91 03 01 	lds	r24, 0x0103
     8de:	83 30       	cpi	r24, 0x03	; 3
     8e0:	a1 f4       	brne	.+40     	; 0x90a <__stack+0x40b>
						{
							//trigger_instant = TCNT1 +(timer1_post_scaller*65536);
							//trigger_instant = 0;
							trigger_instant = 0;//pre_trigger_samples;
     8e2:	10 92 20 02 	sts	0x0220, r1
     8e6:	10 92 21 02 	sts	0x0221, r1
     8ea:	10 92 22 02 	sts	0x0222, r1
     8ee:	10 92 23 02 	sts	0x0223, r1
							pre_trigger_samples = 0;
     8f2:	10 92 09 02 	sts	0x0209, r1
     8f6:	10 92 0a 02 	sts	0x020A, r1
     8fa:	10 92 0b 02 	sts	0x020B, r1
     8fe:	10 92 0c 02 	sts	0x020C, r1
							address_t = 0;
     902:	10 92 09 01 	sts	0x0109, r1
     906:	10 92 08 01 	sts	0x0108, r1
							//LED_ON;
							//pre_trigger_samples = 0;
						}
					
						state_machine = 2;
     90a:	82 e0       	ldi	r24, 0x02	; 2
     90c:	80 93 23 01 	sts	0x0123, r24
						//Tell PC software that we are busy waiting for trigger
						stream[1] = 97;	//Waiting for trigger
     910:	21 e6       	ldi	r18, 0x61	; 97
     912:	20 93 26 01 	sts	0x0126, r18
						stream[0] = USB_FEEDBACK;
     916:	85 e0       	ldi	r24, 0x05	; 5
     918:	80 93 25 01 	sts	0x0125, r24
     91c:	e2 cc       	rjmp	.-1596   	; 0x2e2 <main+0x1c6>
					}
				break;

				case 2: //waiting for trigger, then wait for end of sampling	
					if (stream[135] > 1)
     91e:	80 91 ac 01 	lds	r24, 0x01AC
     922:	82 30       	cpi	r24, 0x02	; 2
     924:	88 f5       	brcc	.+98     	; 0x988 <__stack+0x489>
						address_t = (0x3FFFF&((0x3FFFF & (trigger_instant/sample_length))-pre_trigger_samples))/8; //address to start reading data
						trigged = 1;
						//LED_ON;
						PCMSK1 = 0x0; //disable any further interrupts
					}
					else if (stream[135] > 0)
     926:	80 91 ac 01 	lds	r24, 0x01AC
     92a:	88 23       	and	r24, r24
     92c:	09 f4       	brne	.+2      	; 0x930 <__stack+0x431>
     92e:	74 c0       	rjmp	.+232    	; 0xa18 <__stack+0x519>
					{
						switch(trigger_type)
     930:	80 91 03 01 	lds	r24, 0x0103
     934:	81 30       	cpi	r24, 0x01	; 1
     936:	a9 f0       	breq	.+42     	; 0x962 <__stack+0x463>
     938:	81 30       	cpi	r24, 0x01	; 1
     93a:	20 f0       	brcs	.+8      	; 0x944 <__stack+0x445>
     93c:	82 30       	cpi	r24, 0x02	; 2
     93e:	09 f0       	breq	.+2      	; 0x942 <__stack+0x443>
     940:	6b c0       	rjmp	.+214    	; 0xa18 <__stack+0x519>
     942:	1d c0       	rjmp	.+58     	; 0x97e <__stack+0x47f>
						{
							case 0: //falling edge
								if ( (stream[136]  & (1<<(trigger_channel - 1))) == 0)  //make sure the selected channel had the requested edge
     944:	20 91 ad 01 	lds	r18, 0x01AD
     948:	80 91 14 01 	lds	r24, 0x0114
     94c:	30 e0       	ldi	r19, 0x00	; 0
     94e:	90 e0       	ldi	r25, 0x00	; 0
     950:	01 97       	sbiw	r24, 0x01	; 1
     952:	02 c0       	rjmp	.+4      	; 0x958 <__stack+0x459>
     954:	35 95       	asr	r19
     956:	27 95       	ror	r18
     958:	8a 95       	dec	r24
     95a:	e2 f7       	brpl	.-8      	; 0x954 <__stack+0x455>
     95c:	20 fd       	sbrc	r18, 0
     95e:	5c c0       	rjmp	.+184    	; 0xa18 <__stack+0x519>
     960:	0e c0       	rjmp	.+28     	; 0x97e <__stack+0x47f>
										PCMSK1 = 0x0; //disable any further interrupts
									}
								}
							break;
							case 1:
								if ( (stream[136] & (1<<(trigger_channel - 1))) != 0)  //make sure the selected channel had the requested edge
     962:	20 91 ad 01 	lds	r18, 0x01AD
     966:	80 91 14 01 	lds	r24, 0x0114
     96a:	30 e0       	ldi	r19, 0x00	; 0
     96c:	90 e0       	ldi	r25, 0x00	; 0
     96e:	01 97       	sbiw	r24, 0x01	; 1
     970:	02 c0       	rjmp	.+4      	; 0x976 <__stack+0x477>
     972:	35 95       	asr	r19
     974:	27 95       	ror	r18
     976:	8a 95       	dec	r24
     978:	e2 f7       	brpl	.-8      	; 0x972 <__stack+0x473>
     97a:	20 ff       	sbrs	r18, 0
     97c:	4d c0       	rjmp	.+154    	; 0xa18 <__stack+0x519>
										PCMSK1 = 0x0; //disable any further interrupts
									}
								}
							break;
							case 2:
								if (trigged == 0)
     97e:	80 91 13 02 	lds	r24, 0x0213
     982:	88 23       	and	r24, r24
     984:	09 f0       	breq	.+2      	; 0x988 <__stack+0x489>
     986:	48 c0       	rjmp	.+144    	; 0xa18 <__stack+0x519>
								{
									trigger_instant = TCNT1 +(timer1_post_scaller*65536);
     988:	20 91 84 00 	lds	r18, 0x0084
     98c:	30 91 85 00 	lds	r19, 0x0085
     990:	80 91 19 02 	lds	r24, 0x0219
     994:	90 91 1a 02 	lds	r25, 0x021A
     998:	a0 e0       	ldi	r26, 0x00	; 0
     99a:	b0 e0       	ldi	r27, 0x00	; 0
     99c:	dc 01       	movw	r26, r24
     99e:	99 27       	eor	r25, r25
     9a0:	88 27       	eor	r24, r24
     9a2:	40 e0       	ldi	r20, 0x00	; 0
     9a4:	50 e0       	ldi	r21, 0x00	; 0
     9a6:	82 0f       	add	r24, r18
     9a8:	93 1f       	adc	r25, r19
     9aa:	a4 1f       	adc	r26, r20
     9ac:	b5 1f       	adc	r27, r21
     9ae:	80 93 20 02 	sts	0x0220, r24
     9b2:	90 93 21 02 	sts	0x0221, r25
     9b6:	a0 93 22 02 	sts	0x0222, r26
     9ba:	b0 93 23 02 	sts	0x0223, r27
									address_t = (0x3FFFF&((0x3FFFF & (trigger_instant/sample_length))-pre_trigger_samples))/8; //address to start reading data
     9be:	60 91 20 02 	lds	r22, 0x0220
     9c2:	70 91 21 02 	lds	r23, 0x0221
     9c6:	80 91 22 02 	lds	r24, 0x0222
     9ca:	90 91 23 02 	lds	r25, 0x0223
     9ce:	20 91 0c 01 	lds	r18, 0x010C
     9d2:	30 91 0d 01 	lds	r19, 0x010D
     9d6:	e0 90 09 02 	lds	r14, 0x0209
     9da:	f0 90 0a 02 	lds	r15, 0x020A
     9de:	00 91 0b 02 	lds	r16, 0x020B
     9e2:	10 91 0c 02 	lds	r17, 0x020C
     9e6:	40 e0       	ldi	r20, 0x00	; 0
     9e8:	50 e0       	ldi	r21, 0x00	; 0
     9ea:	0e 94 01 0b 	call	0x1602	; 0x1602 <__udivmodsi4>
     9ee:	2e 19       	sub	r18, r14
     9f0:	3f 09       	sbc	r19, r15
     9f2:	40 0b       	sbc	r20, r16
     9f4:	51 0b       	sbc	r21, r17
     9f6:	43 70       	andi	r20, 0x03	; 3
     9f8:	50 70       	andi	r21, 0x00	; 0
     9fa:	83 e0       	ldi	r24, 0x03	; 3
     9fc:	56 95       	lsr	r21
     9fe:	47 95       	ror	r20
     a00:	37 95       	ror	r19
     a02:	27 95       	ror	r18
     a04:	8a 95       	dec	r24
     a06:	d1 f7       	brne	.-12     	; 0x9fc <__stack+0x4fd>
     a08:	30 93 09 01 	sts	0x0109, r19
     a0c:	20 93 08 01 	sts	0x0108, r18
									trigged = 1;
     a10:	50 92 13 02 	sts	0x0213, r5
									//LED_ON;
									PCMSK1 = 0x0; //disable any further interrupts
     a14:	10 92 6c 00 	sts	0x006C, r1
							default:
							break;
						}
					}
					//wait for trigger to start pooling timer1 (to catch exactly n_samples
					if ((trigged == 1) || (trigger_type == TRIG_NULL))
     a18:	80 91 13 02 	lds	r24, 0x0213
     a1c:	81 30       	cpi	r24, 0x01	; 1
     a1e:	29 f0       	breq	.+10     	; 0xa2a <__stack+0x52b>
     a20:	80 91 03 01 	lds	r24, 0x0103
     a24:	83 30       	cpi	r24, 0x03	; 3
     a26:	09 f0       	breq	.+2      	; 0xa2a <__stack+0x52b>
     a28:	eb c0       	rjmp	.+470    	; 0xc00 <__stack+0x701>
					{
				
						
						stream[1] = 98;	//Tell PC i am collecting data
     a2a:	82 e6       	ldi	r24, 0x62	; 98
     a2c:	80 93 26 01 	sts	0x0126, r24
						stream[0] = USB_FEEDBACK;
     a30:	95 e0       	ldi	r25, 0x05	; 5
     a32:	90 93 25 01 	sts	0x0125, r25
						trigger_instant = TCNT1 +(timer1_post_scaller*65536);
     a36:	20 91 84 00 	lds	r18, 0x0084
     a3a:	30 91 85 00 	lds	r19, 0x0085
     a3e:	80 91 19 02 	lds	r24, 0x0219
     a42:	90 91 1a 02 	lds	r25, 0x021A
     a46:	a0 e0       	ldi	r26, 0x00	; 0
     a48:	b0 e0       	ldi	r27, 0x00	; 0
     a4a:	dc 01       	movw	r26, r24
     a4c:	99 27       	eor	r25, r25
     a4e:	88 27       	eor	r24, r24
     a50:	40 e0       	ldi	r20, 0x00	; 0
     a52:	50 e0       	ldi	r21, 0x00	; 0
     a54:	82 0f       	add	r24, r18
     a56:	93 1f       	adc	r25, r19
     a58:	a4 1f       	adc	r26, r20
     a5a:	b5 1f       	adc	r27, r21
     a5c:	80 93 20 02 	sts	0x0220, r24
     a60:	90 93 21 02 	sts	0x0221, r25
     a64:	a0 93 22 02 	sts	0x0222, r26
     a68:	b0 93 23 02 	sts	0x0223, r27

						memcpy((void*)(&trigger_count_delay), (void*)(&stream[133]),2);
     a6c:	80 91 aa 01 	lds	r24, 0x01AA
     a70:	90 91 ab 01 	lds	r25, 0x01AB
     a74:	9d 83       	std	Y+5, r25	; 0x05
     a76:	8c 83       	std	Y+4, r24	; 0x04

						if (trigger_count_delay > 0)
     a78:	8c 81       	ldd	r24, Y+4	; 0x04
     a7a:	9d 81       	ldd	r25, Y+5	; 0x05
     a7c:	89 2b       	or	r24, r25
     a7e:	09 f4       	brne	.+2      	; 0xa82 <__stack+0x583>
     a80:	a2 c0       	rjmp	.+324    	; 0xbc6 <__stack+0x6c7>
						{
							for (delay_count=0; delay_count< trigger_count_delay; delay_count++)
     a82:	1f 82       	std	Y+7, r1	; 0x07
     a84:	1e 82       	std	Y+6, r1	; 0x06
     a86:	09 c0       	rjmp	.+18     	; 0xa9a <__stack+0x59b>
     a88:	88 e8       	ldi	r24, 0x88	; 136
     a8a:	93 e1       	ldi	r25, 0x13	; 19
     a8c:	01 97       	sbiw	r24, 0x01	; 1
     a8e:	f1 f7       	brne	.-4      	; 0xa8c <__stack+0x58d>
     a90:	8e 81       	ldd	r24, Y+6	; 0x06
     a92:	9f 81       	ldd	r25, Y+7	; 0x07
     a94:	01 96       	adiw	r24, 0x01	; 1
     a96:	9f 83       	std	Y+7, r25	; 0x07
     a98:	8e 83       	std	Y+6, r24	; 0x06
     a9a:	2e 81       	ldd	r18, Y+6	; 0x06
     a9c:	3f 81       	ldd	r19, Y+7	; 0x07
     a9e:	8c 81       	ldd	r24, Y+4	; 0x04
     aa0:	9d 81       	ldd	r25, Y+5	; 0x05
     aa2:	28 17       	cp	r18, r24
     aa4:	39 07       	cpc	r19, r25
     aa6:	80 f3       	brcs	.-32     	; 0xa88 <__stack+0x589>
							{
								//_delay_ms(trigger_count_delay);
								_delay_ms(1);
							}
							trigger_instant = TCNT1 +(timer1_post_scaller*65536);
     aa8:	20 91 84 00 	lds	r18, 0x0084
     aac:	30 91 85 00 	lds	r19, 0x0085
     ab0:	80 91 19 02 	lds	r24, 0x0219
     ab4:	90 91 1a 02 	lds	r25, 0x021A
     ab8:	a0 e0       	ldi	r26, 0x00	; 0
     aba:	b0 e0       	ldi	r27, 0x00	; 0
     abc:	dc 01       	movw	r26, r24
     abe:	99 27       	eor	r25, r25
     ac0:	88 27       	eor	r24, r24
     ac2:	40 e0       	ldi	r20, 0x00	; 0
     ac4:	50 e0       	ldi	r21, 0x00	; 0
     ac6:	82 0f       	add	r24, r18
     ac8:	93 1f       	adc	r25, r19
     aca:	a4 1f       	adc	r26, r20
     acc:	b5 1f       	adc	r27, r21
     ace:	80 93 20 02 	sts	0x0220, r24
     ad2:	90 93 21 02 	sts	0x0221, r25
     ad6:	a0 93 22 02 	sts	0x0222, r26
     ada:	b0 93 23 02 	sts	0x0223, r27
							address_t = (0x3FFFF&((0x3FFFF & (trigger_instant/sample_length))-pre_trigger_samples))/8; //address to start reading data
     ade:	60 91 20 02 	lds	r22, 0x0220
     ae2:	70 91 21 02 	lds	r23, 0x0221
     ae6:	80 91 22 02 	lds	r24, 0x0222
     aea:	90 91 23 02 	lds	r25, 0x0223
     aee:	20 91 0c 01 	lds	r18, 0x010C
     af2:	30 91 0d 01 	lds	r19, 0x010D
     af6:	e0 90 09 02 	lds	r14, 0x0209
     afa:	f0 90 0a 02 	lds	r15, 0x020A
     afe:	00 91 0b 02 	lds	r16, 0x020B
     b02:	10 91 0c 02 	lds	r17, 0x020C
     b06:	40 e0       	ldi	r20, 0x00	; 0
     b08:	50 e0       	ldi	r21, 0x00	; 0
     b0a:	0e 94 01 0b 	call	0x1602	; 0x1602 <__udivmodsi4>
     b0e:	2e 19       	sub	r18, r14
     b10:	3f 09       	sbc	r19, r15
     b12:	40 0b       	sbc	r20, r16
     b14:	51 0b       	sbc	r21, r17
     b16:	43 70       	andi	r20, 0x03	; 3
     b18:	50 70       	andi	r21, 0x00	; 0
     b1a:	f3 e0       	ldi	r31, 0x03	; 3
     b1c:	56 95       	lsr	r21
     b1e:	47 95       	ror	r20
     b20:	37 95       	ror	r19
     b22:	27 95       	ror	r18
     b24:	fa 95       	dec	r31
     b26:	d1 f7       	brne	.-12     	; 0xb1c <__stack+0x61d>
     b28:	30 93 09 01 	sts	0x0109, r19
     b2c:	20 93 08 01 	sts	0x0108, r18
     b30:	4a c0       	rjmp	.+148    	; 0xbc6 <__stack+0x6c7>
						while((abort_sequence == 0) && (sampling_done == 0))
						{
							//check if sampling is done, according to the number of post trigger samples requested by the end user
							//if (((((TCNT1 +(timer1_post_scaller*65536))/sample_length)) - trigger_instant) > post_trigger_samples) //******** added -trigger_instant
							if 	(
										(
     b32:	e0 90 84 00 	lds	r14, 0x0084
     b36:	f0 90 85 00 	lds	r15, 0x0085
     b3a:	60 91 19 02 	lds	r22, 0x0219
     b3e:	70 91 1a 02 	lds	r23, 0x021A
     b42:	a0 90 20 02 	lds	r10, 0x0220
     b46:	b0 90 21 02 	lds	r11, 0x0221
     b4a:	c0 90 22 02 	lds	r12, 0x0222
     b4e:	d0 90 23 02 	lds	r13, 0x0223
     b52:	20 91 0c 01 	lds	r18, 0x010C
     b56:	30 91 0d 01 	lds	r19, 0x010D
     b5a:	60 90 1f 01 	lds	r6, 0x011F
     b5e:	70 90 20 01 	lds	r7, 0x0120
     b62:	80 90 21 01 	lds	r8, 0x0121
     b66:	90 90 22 01 	lds	r9, 0x0122

						while((abort_sequence == 0) && (sampling_done == 0))
						{
							//check if sampling is done, according to the number of post trigger samples requested by the end user
							//if (((((TCNT1 +(timer1_post_scaller*65536))/sample_length)) - trigger_instant) > post_trigger_samples) //******** added -trigger_instant
							if 	(
     b6a:	80 e0       	ldi	r24, 0x00	; 0
     b6c:	90 e0       	ldi	r25, 0x00	; 0
     b6e:	cb 01       	movw	r24, r22
     b70:	77 27       	eor	r23, r23
     b72:	66 27       	eor	r22, r22
     b74:	00 e0       	ldi	r16, 0x00	; 0
     b76:	10 e0       	ldi	r17, 0x00	; 0
     b78:	6e 0d       	add	r22, r14
     b7a:	7f 1d       	adc	r23, r15
     b7c:	80 1f       	adc	r24, r16
     b7e:	91 1f       	adc	r25, r17
     b80:	6a 19       	sub	r22, r10
     b82:	7b 09       	sbc	r23, r11
     b84:	8c 09       	sbc	r24, r12
     b86:	9d 09       	sbc	r25, r13
     b88:	40 e0       	ldi	r20, 0x00	; 0
     b8a:	50 e0       	ldi	r21, 0x00	; 0
     b8c:	0e 94 01 0b 	call	0x1602	; 0x1602 <__udivmodsi4>
     b90:	62 16       	cp	r6, r18
     b92:	73 06       	cpc	r7, r19
     b94:	84 06       	cpc	r8, r20
     b96:	95 06       	cpc	r9, r21
     b98:	b0 f4       	brcc	.+44     	; 0xbc6 <__stack+0x6c7>
										)
							 			> post_trigger_samples
									) 
							{
								//LED_OFF;
								DDR_CS |= CS;	PORT_CS |= (CS);
     b9a:	57 9a       	sbi	0x0a, 7	; 10
     b9c:	5f 9a       	sbi	0x0b, 7	; 11
								
								//disable the clock to the SRAMS
								SRAM_HS_CLK_DIS;
     b9e:	2f 9a       	sbi	0x05, 7	; 5
     ba0:	23 9a       	sbi	0x04, 3	; 4
     ba2:	2b 98       	cbi	0x05, 3	; 5
								DDR_CLK |= (CLK); PORT_CLK &= ~(CLK);
     ba4:	23 9a       	sbi	0x04, 3	; 4
     ba6:	2b 98       	cbi	0x05, 3	; 5
								STOP_TIMER2;
     ba8:	10 92 b0 00 	sts	0x00B0, r1
     bac:	10 92 b1 00 	sts	0x00B1, r1
     bb0:	23 9a       	sbi	0x04, 3	; 4
     bb2:	2b 98       	cbi	0x05, 3	; 5
								STOP_TIMER1;
     bb4:	10 92 81 00 	sts	0x0081, r1
								SRAM_CS_DIS;//sram_cs_end(); //Stop the SRAM sequence
     bb8:	57 98       	cbi	0x0a, 7	; 10
     bba:	5f 98       	cbi	0x0b, 7	; 11
								//Send the data to PC
								sampling_done = 1;
     bbc:	50 92 12 02 	sts	0x0212, r5
								state_machine = 3;
     bc0:	23 e0       	ldi	r18, 0x03	; 3
     bc2:	20 93 23 01 	sts	0x0123, r18
							trigger_instant = TCNT1 +(timer1_post_scaller*65536);
							address_t = (0x3FFFF&((0x3FFFF & (trigger_instant/sample_length))-pre_trigger_samples))/8; //address to start reading data
							
						}

						while((abort_sequence == 0) && (sampling_done == 0))
     bc6:	80 91 1e 01 	lds	r24, 0x011E
     bca:	88 23       	and	r24, r24
     bcc:	29 f4       	brne	.+10     	; 0xbd8 <__stack+0x6d9>
     bce:	80 91 12 02 	lds	r24, 0x0212
     bd2:	88 23       	and	r24, r24
     bd4:	09 f4       	brne	.+2      	; 0xbd8 <__stack+0x6d9>
     bd6:	ad cf       	rjmp	.-166    	; 0xb32 <__stack+0x633>
								state_machine = 3;
							}
					
						}

						if(abort_sequence == 1)
     bd8:	80 91 1e 01 	lds	r24, 0x011E
     bdc:	81 30       	cpi	r24, 0x01	; 1
     bde:	81 f4       	brne	.+32     	; 0xc00 <__stack+0x701>
						{
							SRAM_CS_DIS;
     be0:	57 98       	cbi	0x0a, 7	; 10
     be2:	5f 98       	cbi	0x0b, 7	; 11
							SRAM_HS_CLK_DIS;
     be4:	2f 9a       	sbi	0x05, 7	; 5
     be6:	23 9a       	sbi	0x04, 3	; 4
     be8:	2b 98       	cbi	0x05, 3	; 5
							STOP_TIMER2;
     bea:	10 92 b0 00 	sts	0x00B0, r1
     bee:	10 92 b1 00 	sts	0x00B1, r1
     bf2:	23 9a       	sbi	0x04, 3	; 4
     bf4:	2b 98       	cbi	0x05, 3	; 5
							STOP_TIMER1;
     bf6:	10 92 81 00 	sts	0x0081, r1
						 	state_machine = 99;
     bfa:	83 e6       	ldi	r24, 0x63	; 99
     bfc:	80 93 23 01 	sts	0x0123, r24
						}

					}

					if (abort_sequence == 1)
     c00:	80 91 1e 01 	lds	r24, 0x011E
     c04:	81 30       	cpi	r24, 0x01	; 1
     c06:	09 f0       	breq	.+2      	; 0xc0a <__stack+0x70b>
     c08:	6c cb       	rjmp	.-2344   	; 0x2e2 <main+0x1c6>
					{
						SRAM_CS_DIS;
     c0a:	57 98       	cbi	0x0a, 7	; 10
     c0c:	5f 98       	cbi	0x0b, 7	; 11
						SRAM_HS_CLK_DIS;
     c0e:	2f 9a       	sbi	0x05, 7	; 5
     c10:	23 9a       	sbi	0x04, 3	; 4
     c12:	2b 98       	cbi	0x05, 3	; 5
						STOP_TIMER2;
     c14:	10 92 b0 00 	sts	0x00B0, r1
     c18:	10 92 b1 00 	sts	0x00B1, r1
     c1c:	23 9a       	sbi	0x04, 3	; 4
     c1e:	2b 98       	cbi	0x05, 3	; 5
						STOP_TIMER1;
     c20:	10 92 81 00 	sts	0x0081, r1
						trigged = 1;
     c24:	80 93 13 02 	sts	0x0213, r24
     c28:	9f c0       	rjmp	.+318    	; 0xd68 <__stack+0x869>
				break;

				case 3: //sampling done send data to PC
					//Send data to PC if any
										
						stream[1] = 96;	//Tell PC i finished collecting data, waiting for transfere
     c2a:	80 e6       	ldi	r24, 0x60	; 96
     c2c:	80 93 26 01 	sts	0x0126, r24
						stream[0] = USB_FEEDBACK;
     c30:	25 e0       	ldi	r18, 0x05	; 5
     c32:	20 93 25 01 	sts	0x0125, r18
						usb_data_read = 0;
     c36:	10 92 04 01 	sts	0x0104, r1

					
						//boost usb speed
						STOP_USB_TIMER;
     c3a:	15 bc       	out	0x25, r1	; 37
						for (j=0; j<4; j++) //loop to cycle between the 4 channels
     c3c:	1a 82       	std	Y+2, r1	; 0x02
     c3e:	8e c0       	rjmp	.+284    	; 0xd5c <__stack+0x85d>
						{
							//address = (0x3FFFF&((0x3FFFF & trigger_instant)-pre_trigger_samples))/8; //address to start reading data
							address = address_t;
     c40:	80 91 08 01 	lds	r24, 0x0108
     c44:	90 91 09 01 	lds	r25, 0x0109
     c48:	90 93 06 01 	sts	0x0106, r25
     c4c:	80 93 05 01 	sts	0x0105, r24
							transfered_bytes=0;
     c50:	10 92 1e 02 	sts	0x021E, r1
     c54:	10 92 1d 02 	sts	0x021D, r1
							sending_done = 0;
     c58:	10 92 1f 02 	sts	0x021F, r1
							signature=0;
     c5c:	1b 82       	std	Y+3, r1	; 0x03
     c5e:	72 c0       	rjmp	.+228    	; 0xd44 <__stack+0x845>
							while((abort_sequence == 0) && (sending_done == 0))
							{
								usbPoll();
     c60:	0e 94 78 07 	call	0xef0	; 0xef0 <usbPoll>
								if (new_usb_data == 1)
     c64:	80 91 0f 02 	lds	r24, 0x020F
     c68:	81 30       	cpi	r24, 0x01	; 1
     c6a:	39 f4       	brne	.+14     	; 0xc7a <__stack+0x77b>
								{
									new_usb_data = 0;
     c6c:	10 92 0f 02 	sts	0x020F, r1
									abort_sequence = 1;
     c70:	80 93 1e 01 	sts	0x011E, r24
									state_machine = 99;
     c74:	83 e6       	ldi	r24, 0x63	; 99
     c76:	80 93 23 01 	sts	0x0123, r24
								}
								if (usb_data_read == 1)	//put new data in stream[] table, only if the previous data have been read by host
     c7a:	a0 90 04 01 	lds	r10, 0x0104
     c7e:	91 e0       	ldi	r25, 0x01	; 1
     c80:	a9 16       	cp	r10, r25
     c82:	09 f0       	breq	.+2      	; 0xc86 <__stack+0x787>
     c84:	5f c0       	rjmp	.+190    	; 0xd44 <__stack+0x845>
								{
									LED_ON;
     c86:	50 9a       	sbi	0x0a, 0	; 10
     c88:	58 9a       	sbi	0x0b, 0	; 11
									//LED_OFF;
									usb_data_read=0;
     c8a:	10 92 04 01 	sts	0x0104, r1
									memset((void*)stream,0,128);
     c8e:	84 2d       	mov	r24, r4
     c90:	98 85       	ldd	r25, Y+8	; 0x08
     c92:	60 e0       	ldi	r22, 0x00	; 0
     c94:	70 e0       	ldi	r23, 0x00	; 0
     c96:	40 e8       	ldi	r20, 0x80	; 128
     c98:	50 e0       	ldi	r21, 0x00	; 0
     c9a:	0e 94 2c 0b 	call	0x1658	; 0x1658 <memset>
									sram_read_block(address, j,124, (uchar*)&stream[4]);
     c9e:	80 91 05 01 	lds	r24, 0x0105
     ca2:	90 91 06 01 	lds	r25, 0x0106
     ca6:	6a 81       	ldd	r22, Y+2	; 0x02
     ca8:	4c e7       	ldi	r20, 0x7C	; 124
     caa:	29 e2       	ldi	r18, 0x29	; 41
     cac:	31 e0       	ldi	r19, 0x01	; 1
     cae:	0e 94 dd 1d 	call	0x3bba	; 0x3bba <sram_read_block>
									//stream[4] = (address/124);
									stream[1] = j;	
     cb2:	8a 81       	ldd	r24, Y+2	; 0x02
     cb4:	80 93 26 01 	sts	0x0126, r24
									stream[2]= signature++;	//just an indicator for the HOST to differentiate btw old/new data
     cb8:	8b 81       	ldd	r24, Y+3	; 0x03
     cba:	80 93 27 01 	sts	0x0127, r24
     cbe:	8f 5f       	subi	r24, 0xFF	; 255
     cc0:	8b 83       	std	Y+3, r24	; 0x03
									stream[0] = USB_FEEDBACK;
     cc2:	25 e0       	ldi	r18, 0x05	; 5
     cc4:	20 93 25 01 	sts	0x0125, r18
									address += 124; //124 bytes have been sent
     cc8:	80 91 05 01 	lds	r24, 0x0105
     ccc:	90 91 06 01 	lds	r25, 0x0106
     cd0:	84 58       	subi	r24, 0x84	; 132
     cd2:	9f 4f       	sbci	r25, 0xFF	; 255
     cd4:	90 93 06 01 	sts	0x0106, r25
     cd8:	80 93 05 01 	sts	0x0105, r24
									transfered_bytes += 124;
     cdc:	80 91 1d 02 	lds	r24, 0x021D
     ce0:	90 91 1e 02 	lds	r25, 0x021E
     ce4:	84 58       	subi	r24, 0x84	; 132
     ce6:	9f 4f       	sbci	r25, 0xFF	; 255
     ce8:	90 93 1e 02 	sts	0x021E, r25
     cec:	80 93 1d 02 	sts	0x021D, r24
									//if ((address & 0x7FFF) >= ((pre_trigger_samples+post_trigger_samples)/8))
									if (transfered_bytes >= ((pre_trigger_samples+post_trigger_samples)/8))
     cf0:	20 91 1d 02 	lds	r18, 0x021D
     cf4:	30 91 1e 02 	lds	r19, 0x021E
     cf8:	e0 90 09 02 	lds	r14, 0x0209
     cfc:	f0 90 0a 02 	lds	r15, 0x020A
     d00:	00 91 0b 02 	lds	r16, 0x020B
     d04:	10 91 0c 02 	lds	r17, 0x020C
     d08:	80 91 1f 01 	lds	r24, 0x011F
     d0c:	90 91 20 01 	lds	r25, 0x0120
     d10:	a0 91 21 01 	lds	r26, 0x0121
     d14:	b0 91 22 01 	lds	r27, 0x0122
     d18:	40 e0       	ldi	r20, 0x00	; 0
     d1a:	50 e0       	ldi	r21, 0x00	; 0
     d1c:	8e 0d       	add	r24, r14
     d1e:	9f 1d       	adc	r25, r15
     d20:	a0 1f       	adc	r26, r16
     d22:	b1 1f       	adc	r27, r17
     d24:	63 e0       	ldi	r22, 0x03	; 3
     d26:	b6 95       	lsr	r27
     d28:	a7 95       	ror	r26
     d2a:	97 95       	ror	r25
     d2c:	87 95       	ror	r24
     d2e:	6a 95       	dec	r22
     d30:	d1 f7       	brne	.-12     	; 0xd26 <__stack+0x827>
     d32:	28 17       	cp	r18, r24
     d34:	39 07       	cpc	r19, r25
     d36:	4a 07       	cpc	r20, r26
     d38:	5b 07       	cpc	r21, r27
     d3a:	10 f0       	brcs	.+4      	; 0xd40 <__stack+0x841>
									{
										sending_done=1;
     d3c:	a0 92 1f 02 	sts	0x021F, r10
									}
									LED_OFF;
     d40:	50 9a       	sbi	0x0a, 0	; 10
     d42:	58 98       	cbi	0x0b, 0	; 11
							//address = (0x3FFFF&((0x3FFFF & trigger_instant)-pre_trigger_samples))/8; //address to start reading data
							address = address_t;
							transfered_bytes=0;
							sending_done = 0;
							signature=0;
							while((abort_sequence == 0) && (sending_done == 0))
     d44:	80 91 1e 01 	lds	r24, 0x011E
     d48:	88 23       	and	r24, r24
     d4a:	29 f4       	brne	.+10     	; 0xd56 <__stack+0x857>
     d4c:	80 91 1f 02 	lds	r24, 0x021F
     d50:	88 23       	and	r24, r24
     d52:	09 f4       	brne	.+2      	; 0xd56 <__stack+0x857>
     d54:	85 cf       	rjmp	.-246    	; 0xc60 <__stack+0x761>
						usb_data_read = 0;

					
						//boost usb speed
						STOP_USB_TIMER;
						for (j=0; j<4; j++) //loop to cycle between the 4 channels
     d56:	8a 81       	ldd	r24, Y+2	; 0x02
     d58:	8f 5f       	subi	r24, 0xFF	; 255
     d5a:	8a 83       	std	Y+2, r24	; 0x02
     d5c:	8a 81       	ldd	r24, Y+2	; 0x02
     d5e:	84 30       	cpi	r24, 0x04	; 4
     d60:	08 f4       	brcc	.+2      	; 0xd64 <__stack+0x865>
     d62:	6e cf       	rjmp	.-292    	; 0xc40 <__stack+0x741>
								}//endif (usb_data_read == 1)
							}//end while ((abort_sequence == 0) && (sending_done == 0))
						}//end for loop to cycle between the 4 channels

						//back to normal speed
						START_USB_TIMER;
     d64:	85 e0       	ldi	r24, 0x05	; 5
     d66:	85 bd       	out	0x25, r24	; 37

						state_machine=99; //IDLE STATE
     d68:	93 e6       	ldi	r25, 0x63	; 99
     d6a:	90 93 23 01 	sts	0x0123, r25
     d6e:	b9 ca       	rjmp	.-2702   	; 0x2e2 <main+0x1c6>
				break;
				case 7: //Store usb update data in SRAM0

					STOP_USB_TIMER
     d70:	15 bc       	out	0x25, r1	; 37
					new_usb_data = 1;
     d72:	50 92 0f 02 	sts	0x020F, r5
					sending_done = 0;
     d76:	10 92 1f 02 	sts	0x021F, r1
					gen_mode = 1;
     d7a:	50 92 17 01 	sts	0x0117, r5
     d7e:	1a c0       	rjmp	.+52     	; 0xdb4 <__stack+0x8b5>
					while(sending_done == 0)
					{
						usbPoll();
     d80:	0e 94 78 07 	call	0xef0	; 0xef0 <usbPoll>
						if (new_usb_data == 1)
     d84:	90 91 0f 02 	lds	r25, 0x020F
     d88:	91 30       	cpi	r25, 0x01	; 1
     d8a:	a1 f4       	brne	.+40     	; 0xdb4 <__stack+0x8b5>
						{
							if (stream[0] == 7)
     d8c:	80 91 25 01 	lds	r24, 0x0125
     d90:	87 30       	cpi	r24, 0x07	; 7
     d92:	71 f4       	brne	.+28     	; 0xdb0 <__stack+0x8b1>
							{
								new_usb_data = 0;
     d94:	10 92 0f 02 	sts	0x020F, r1
								LED_ON
     d98:	50 9a       	sbi	0x0a, 0	; 10
     d9a:	58 9a       	sbi	0x0b, 0	; 11
								//memcpy((void*)&temp_add,(void*)&stream[1],2);
								//memset((void*)&stream[4],test_counter++,124);
								sram_write_block(update_channel,124, (uchar*)&stream[4]);
     d9c:	80 91 11 02 	lds	r24, 0x0211
     da0:	6c e7       	ldi	r22, 0x7C	; 124
     da2:	49 e2       	ldi	r20, 0x29	; 41
     da4:	51 e0       	ldi	r21, 0x01	; 1
     da6:	0e 94 1d 1d 	call	0x3a3a	; 0x3a3a <sram_write_block>
					
								LED_OFF
     daa:	50 9a       	sbi	0x0a, 0	; 10
     dac:	58 98       	cbi	0x0b, 0	; 11
     dae:	02 c0       	rjmp	.+4      	; 0xdb4 <__stack+0x8b5>
							}
							else
							{
								sending_done = 1;
     db0:	90 93 1f 02 	sts	0x021F, r25

					STOP_USB_TIMER
					new_usb_data = 1;
					sending_done = 0;
					gen_mode = 1;
					while(sending_done == 0)
     db4:	80 91 1f 02 	lds	r24, 0x021F
     db8:	88 23       	and	r24, r24
     dba:	11 f3       	breq	.-60     	; 0xd80 <__stack+0x881>
							{
								sending_done = 1;
							}
						}
					}
					START_USB_TIMER;
     dbc:	25 e0       	ldi	r18, 0x05	; 5
     dbe:	25 bd       	out	0x25, r18	; 37
     dc0:	19 c0       	rjmp	.+50     	; 0xdf4 <__stack+0x8f5>
					state_machine = 0; //after storing the data go back to idle
				break;	
				case 98:
					//clear  all SRAMS
					sram_mixed_setup(INST_WRITE, INST_WRITE, 0);
     dc2:	82 e0       	ldi	r24, 0x02	; 2
     dc4:	62 e0       	ldi	r22, 0x02	; 2
     dc6:	40 e0       	ldi	r20, 0x00	; 0
     dc8:	50 e0       	ldi	r21, 0x00	; 0
     dca:	0e 94 65 1d 	call	0x3aca	; 0x3aca <sram_mixed_setup>
					sram_out(0,CH_ALL);
     dce:	80 e0       	ldi	r24, 0x00	; 0
     dd0:	63 e6       	ldi	r22, 0x63	; 99
     dd2:	0e 94 00 1c 	call	0x3800	; 0x3800 <sram_out>
					SRAM_HS_CLK_ENA
     dd6:	2f 98       	cbi	0x05, 7	; 5
     dd8:	23 9a       	sbi	0x04, 3	; 4
     dda:	2b 9a       	sbi	0x05, 3	; 5
     ddc:	84 ec       	ldi	r24, 0xC4	; 196
     dde:	99 e0       	ldi	r25, 0x09	; 9
     de0:	f1 01       	movw	r30, r2
     de2:	31 97       	sbiw	r30, 0x01	; 1
     de4:	f1 f7       	brne	.-4      	; 0xde2 <__stack+0x8e3>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     de6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     de8:	d9 f7       	brne	.-10     	; 0xde0 <__stack+0x8e1>
			    	_delay_ms(250);
					SRAM_HS_CLK_DIS;
     dea:	2f 9a       	sbi	0x05, 7	; 5
     dec:	23 9a       	sbi	0x04, 3	; 4
     dee:	2b 98       	cbi	0x05, 3	; 5
					sram_cs_end();
     df0:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <sram_cs_end>
					state_machine = 0;
     df4:	10 92 23 01 	sts	0x0123, r1
     df8:	74 ca       	rjmp	.-2840   	; 0x2e2 <main+0x1c6>
				break;

				case 99:
						if(gen_mode == 1)
     dfa:	80 91 17 01 	lds	r24, 0x0117
     dfe:	81 30       	cpi	r24, 0x01	; 1
     e00:	b9 f4       	brne	.+46     	; 0xe30 <__stack+0x931>
						{
							SRAM_CS_DIS;
     e02:	57 98       	cbi	0x0a, 7	; 10
     e04:	5f 98       	cbi	0x0b, 7	; 11
							SRAM_HS_CLK_DIS;
     e06:	2f 9a       	sbi	0x05, 7	; 5
     e08:	23 9a       	sbi	0x04, 3	; 4
     e0a:	2b 98       	cbi	0x05, 3	; 5
							STOP_TIMER2;
     e0c:	10 92 b0 00 	sts	0x00B0, r1
     e10:	10 92 b1 00 	sts	0x00B1, r1
     e14:	23 9a       	sbi	0x04, 3	; 4
     e16:	2b 98       	cbi	0x05, 3	; 5
							sram_cs_end(); //Stop the SRAM sequence
     e18:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <sram_cs_end>
						
							ISOLATE_PROBES
     e1c:	21 9a       	sbi	0x04, 1	; 4
     e1e:	29 9a       	sbi	0x05, 1	; 5
     e20:	20 9a       	sbi	0x04, 0	; 4
     e22:	28 9a       	sbi	0x05, 0	; 5
     e24:	22 9a       	sbi	0x04, 2	; 4
     e26:	2a 9a       	sbi	0x05, 2	; 5
     e28:	24 9a       	sbi	0x04, 4	; 4
     e2a:	2c 9a       	sbi	0x05, 4	; 5
							gen_mode = 0;
     e2c:	10 92 17 01 	sts	0x0117, r1
						}
						PCMSK1 = 0x0;
     e30:	10 92 6c 00 	sts	0x006C, r1
						//LED_OFF
						ISOLATE_PROBES
     e34:	21 9a       	sbi	0x04, 1	; 4
     e36:	29 9a       	sbi	0x05, 1	; 5
     e38:	20 9a       	sbi	0x04, 0	; 4
     e3a:	28 9a       	sbi	0x05, 0	; 5
     e3c:	22 9a       	sbi	0x04, 2	; 4
     e3e:	2a 9a       	sbi	0x05, 2	; 5
     e40:	24 9a       	sbi	0x04, 4	; 4
     e42:	2c 9a       	sbi	0x05, 4	; 5
						if (usb_data_read == 1) //make sure previous data have been read by HOST
     e44:	80 91 04 01 	lds	r24, 0x0104
     e48:	81 30       	cpi	r24, 0x01	; 1
     e4a:	91 f4       	brne	.+36     	; 0xe70 <__stack+0x971>
						{
							memset((void*)stream,0,128);
     e4c:	84 2d       	mov	r24, r4
     e4e:	98 85       	ldd	r25, Y+8	; 0x08
     e50:	60 e0       	ldi	r22, 0x00	; 0
     e52:	70 e0       	ldi	r23, 0x00	; 0
     e54:	40 e8       	ldi	r20, 0x80	; 128
     e56:	50 e0       	ldi	r21, 0x00	; 0
     e58:	0e 94 2c 0b 	call	0x1658	; 0x1658 <memset>
							state_machine=0; //IDLE STATE
     e5c:	10 92 23 01 	sts	0x0123, r1
							stream[1] = 99;	//Tell PC i finished sending data, and/or currently IDLE
     e60:	83 e6       	ldi	r24, 0x63	; 99
     e62:	80 93 26 01 	sts	0x0126, r24
							stream[0] = USB_FEEDBACK;
     e66:	95 e0       	ldi	r25, 0x05	; 5
     e68:	90 93 25 01 	sts	0x0125, r25
							usb_data_read = 0;
     e6c:	10 92 04 01 	sts	0x0104, r1
						}
						pre_trigger_samples=0;
     e70:	10 92 09 02 	sts	0x0209, r1
     e74:	10 92 0a 02 	sts	0x020A, r1
     e78:	10 92 0b 02 	sts	0x020B, r1
     e7c:	10 92 0c 02 	sts	0x020C, r1
						post_trigger_samples=0;
     e80:	10 92 1f 01 	sts	0x011F, r1
     e84:	10 92 20 01 	sts	0x0120, r1
     e88:	10 92 21 01 	sts	0x0121, r1
     e8c:	10 92 22 01 	sts	0x0122, r1
     e90:	28 ca       	rjmp	.-2992   	; 0x2e2 <main+0x1c6>

00000e92 <usbInit>:
     e92:	e9 e6       	ldi	r30, 0x69	; 105
     e94:	f0 e0       	ldi	r31, 0x00	; 0
     e96:	80 81       	ld	r24, Z
     e98:	82 60       	ori	r24, 0x02	; 2
     e9a:	80 83       	st	Z, r24
     e9c:	e8 9a       	sbi	0x1d, 0	; 29
     e9e:	8b e4       	ldi	r24, 0x4B	; 75
     ea0:	80 93 30 02 	sts	0x0230, r24
     ea4:	8a e5       	ldi	r24, 0x5A	; 90
     ea6:	80 93 2f 02 	sts	0x022F, r24
     eaa:	08 95       	ret

00000eac <usbSetInterrupt>:
     eac:	1f 93       	push	r17
     eae:	dc 01       	movw	r26, r24
     eb0:	16 2f       	mov	r17, r22
     eb2:	80 91 2f 02 	lds	r24, 0x022F
     eb6:	84 ff       	sbrs	r24, 4
     eb8:	07 c0       	rjmp	.+14     	; 0xec8 <usbSetInterrupt+0x1c>
     eba:	80 91 30 02 	lds	r24, 0x0230
     ebe:	98 e8       	ldi	r25, 0x88	; 136
     ec0:	89 27       	eor	r24, r25
     ec2:	80 93 30 02 	sts	0x0230, r24
     ec6:	03 c0       	rjmp	.+6      	; 0xece <usbSetInterrupt+0x22>
     ec8:	8a e5       	ldi	r24, 0x5A	; 90
     eca:	80 93 2f 02 	sts	0x022F, r24
     ece:	91 2f       	mov	r25, r17
     ed0:	e1 e3       	ldi	r30, 0x31	; 49
     ed2:	f2 e0       	ldi	r31, 0x02	; 2
     ed4:	8d 91       	ld	r24, X+
     ed6:	81 93       	st	Z+, r24
     ed8:	91 50       	subi	r25, 0x01	; 1
     eda:	e1 f7       	brne	.-8      	; 0xed4 <usbSetInterrupt+0x28>
     edc:	81 e3       	ldi	r24, 0x31	; 49
     ede:	92 e0       	ldi	r25, 0x02	; 2
     ee0:	61 2f       	mov	r22, r17
     ee2:	0e 94 bb 08 	call	0x1176	; 0x1176 <usbCrc16Append>
     ee6:	1c 5f       	subi	r17, 0xFC	; 252
     ee8:	10 93 2f 02 	sts	0x022F, r17
     eec:	1f 91       	pop	r17
     eee:	08 95       	ret

00000ef0 <usbPoll>:
     ef0:	1f 93       	push	r17
     ef2:	cf 93       	push	r28
     ef4:	df 93       	push	r29
     ef6:	60 91 41 02 	lds	r22, 0x0241
     efa:	63 50       	subi	r22, 0x03	; 3
     efc:	67 fd       	sbrc	r22, 7
     efe:	ba c0       	rjmp	.+372    	; 0x1074 <usbPoll+0x184>
     f00:	80 91 3d 02 	lds	r24, 0x023D
     f04:	cc e0       	ldi	r28, 0x0C	; 12
     f06:	d0 e0       	ldi	r29, 0x00	; 0
     f08:	c8 1b       	sub	r28, r24
     f0a:	d1 09       	sbc	r29, r1
     f0c:	cb 5b       	subi	r28, 0xBB	; 187
     f0e:	dd 4f       	sbci	r29, 0xFD	; 253
     f10:	80 91 3c 02 	lds	r24, 0x023C
     f14:	8d 32       	cpi	r24, 0x2D	; 45
     f16:	09 f0       	breq	.+2      	; 0xf1a <usbPoll+0x2a>
     f18:	9a c0       	rjmp	.+308    	; 0x104e <usbPoll+0x15e>
     f1a:	68 30       	cpi	r22, 0x08	; 8
     f1c:	09 f0       	breq	.+2      	; 0xf20 <usbPoll+0x30>
     f1e:	a8 c0       	rjmp	.+336    	; 0x1070 <usbPoll+0x180>
     f20:	83 ec       	ldi	r24, 0xC3	; 195
     f22:	80 93 24 02 	sts	0x0224, r24
     f26:	8a e5       	ldi	r24, 0x5A	; 90
     f28:	80 93 00 01 	sts	0x0100, r24
     f2c:	10 92 02 01 	sts	0x0102, r1
     f30:	88 81       	ld	r24, Y
     f32:	80 76       	andi	r24, 0x60	; 96
     f34:	41 f0       	breq	.+16     	; 0xf46 <usbPoll+0x56>
     f36:	ce 01       	movw	r24, r28
     f38:	0e 94 9e 0a 	call	0x153c	; 0x153c <usbFunctionSetup>
     f3c:	28 2f       	mov	r18, r24
     f3e:	8f 3f       	cpi	r24, 0xFF	; 255
     f40:	09 f4       	brne	.+2      	; 0xf44 <usbPoll+0x54>
     f42:	74 c0       	rjmp	.+232    	; 0x102c <usbPoll+0x13c>
     f44:	7a c0       	rjmp	.+244    	; 0x103a <usbPoll+0x14a>
     f46:	9a 81       	ldd	r25, Y+2	; 0x02
     f48:	10 92 2d 02 	sts	0x022D, r1
     f4c:	89 81       	ldd	r24, Y+1	; 0x01
     f4e:	88 23       	and	r24, r24
     f50:	21 f4       	brne	.+8      	; 0xf5a <usbPoll+0x6a>
     f52:	10 92 2e 02 	sts	0x022E, r1
     f56:	22 e0       	ldi	r18, 0x02	; 2
     f58:	62 c0       	rjmp	.+196    	; 0x101e <usbPoll+0x12e>
     f5a:	85 30       	cpi	r24, 0x05	; 5
     f5c:	19 f4       	brne	.+6      	; 0xf64 <usbPoll+0x74>
     f5e:	90 93 42 02 	sts	0x0242, r25
     f62:	5c c0       	rjmp	.+184    	; 0x101c <usbPoll+0x12c>
     f64:	86 30       	cpi	r24, 0x06	; 6
     f66:	09 f0       	breq	.+2      	; 0xf6a <usbPoll+0x7a>
     f68:	45 c0       	rjmp	.+138    	; 0xff4 <usbPoll+0x104>
     f6a:	8b 81       	ldd	r24, Y+3	; 0x03
     f6c:	81 30       	cpi	r24, 0x01	; 1
     f6e:	19 f4       	brne	.+6      	; 0xf76 <usbPoll+0x86>
     f70:	84 e9       	ldi	r24, 0x94	; 148
     f72:	90 e0       	ldi	r25, 0x00	; 0
     f74:	1b c0       	rjmp	.+54     	; 0xfac <usbPoll+0xbc>
     f76:	82 30       	cpi	r24, 0x02	; 2
     f78:	41 f4       	brne	.+16     	; 0xf8a <usbPoll+0x9a>
     f7a:	86 ea       	ldi	r24, 0xA6	; 166
     f7c:	90 e0       	ldi	r25, 0x00	; 0
     f7e:	90 93 40 02 	sts	0x0240, r25
     f82:	80 93 3f 02 	sts	0x023F, r24
     f86:	22 e2       	ldi	r18, 0x22	; 34
     f88:	31 c0       	rjmp	.+98     	; 0xfec <usbPoll+0xfc>
     f8a:	83 30       	cpi	r24, 0x03	; 3
     f8c:	d1 f4       	brne	.+52     	; 0xfc2 <usbPoll+0xd2>
     f8e:	8a 81       	ldd	r24, Y+2	; 0x02
     f90:	88 23       	and	r24, r24
     f92:	41 f4       	brne	.+16     	; 0xfa4 <usbPoll+0xb4>
     f94:	88 e6       	ldi	r24, 0x68	; 104
     f96:	90 e0       	ldi	r25, 0x00	; 0
     f98:	90 93 40 02 	sts	0x0240, r25
     f9c:	80 93 3f 02 	sts	0x023F, r24
     fa0:	24 e0       	ldi	r18, 0x04	; 4
     fa2:	24 c0       	rjmp	.+72     	; 0xfec <usbPoll+0xfc>
     fa4:	81 30       	cpi	r24, 0x01	; 1
     fa6:	41 f4       	brne	.+16     	; 0xfb8 <usbPoll+0xc8>
     fa8:	8c e6       	ldi	r24, 0x6C	; 108
     faa:	90 e0       	ldi	r25, 0x00	; 0
     fac:	90 93 40 02 	sts	0x0240, r25
     fb0:	80 93 3f 02 	sts	0x023F, r24
     fb4:	22 e1       	ldi	r18, 0x12	; 18
     fb6:	1a c0       	rjmp	.+52     	; 0xfec <usbPoll+0xfc>
     fb8:	82 30       	cpi	r24, 0x02	; 2
     fba:	b9 f4       	brne	.+46     	; 0xfea <usbPoll+0xfa>
     fbc:	8e e7       	ldi	r24, 0x7E	; 126
     fbe:	90 e0       	ldi	r25, 0x00	; 0
     fc0:	0e c0       	rjmp	.+28     	; 0xfde <usbPoll+0xee>
     fc2:	81 32       	cpi	r24, 0x21	; 33
     fc4:	41 f4       	brne	.+16     	; 0xfd6 <usbPoll+0xe6>
     fc6:	88 eb       	ldi	r24, 0xB8	; 184
     fc8:	90 e0       	ldi	r25, 0x00	; 0
     fca:	90 93 40 02 	sts	0x0240, r25
     fce:	80 93 3f 02 	sts	0x023F, r24
     fd2:	29 e0       	ldi	r18, 0x09	; 9
     fd4:	0b c0       	rjmp	.+22     	; 0xfec <usbPoll+0xfc>
     fd6:	82 32       	cpi	r24, 0x22	; 34
     fd8:	41 f4       	brne	.+16     	; 0xfea <usbPoll+0xfa>
     fda:	88 ec       	ldi	r24, 0xC8	; 200
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	90 93 40 02 	sts	0x0240, r25
     fe2:	80 93 3f 02 	sts	0x023F, r24
     fe6:	26 e1       	ldi	r18, 0x16	; 22
     fe8:	01 c0       	rjmp	.+2      	; 0xfec <usbPoll+0xfc>
     fea:	20 e0       	ldi	r18, 0x00	; 0
     fec:	80 e4       	ldi	r24, 0x40	; 64
     fee:	80 93 02 01 	sts	0x0102, r24
     ff2:	23 c0       	rjmp	.+70     	; 0x103a <usbPoll+0x14a>
     ff4:	88 30       	cpi	r24, 0x08	; 8
     ff6:	21 f4       	brne	.+8      	; 0x1000 <usbPoll+0x110>
     ff8:	21 e0       	ldi	r18, 0x01	; 1
     ffa:	84 e4       	ldi	r24, 0x44	; 68
     ffc:	92 e0       	ldi	r25, 0x02	; 2
     ffe:	11 c0       	rjmp	.+34     	; 0x1022 <usbPoll+0x132>
    1000:	89 30       	cpi	r24, 0x09	; 9
    1002:	19 f4       	brne	.+6      	; 0x100a <usbPoll+0x11a>
    1004:	90 93 44 02 	sts	0x0244, r25
    1008:	09 c0       	rjmp	.+18     	; 0x101c <usbPoll+0x12c>
    100a:	8a 30       	cpi	r24, 0x0A	; 10
    100c:	11 f4       	brne	.+4      	; 0x1012 <usbPoll+0x122>
    100e:	21 e0       	ldi	r18, 0x01	; 1
    1010:	06 c0       	rjmp	.+12     	; 0x101e <usbPoll+0x12e>
    1012:	8b 30       	cpi	r24, 0x0B	; 11
    1014:	19 f4       	brne	.+6      	; 0x101c <usbPoll+0x12c>
    1016:	8b e4       	ldi	r24, 0x4B	; 75
    1018:	80 93 30 02 	sts	0x0230, r24
    101c:	20 e0       	ldi	r18, 0x00	; 0
    101e:	8d e2       	ldi	r24, 0x2D	; 45
    1020:	92 e0       	ldi	r25, 0x02	; 2
    1022:	90 93 40 02 	sts	0x0240, r25
    1026:	80 93 3f 02 	sts	0x023F, r24
    102a:	07 c0       	rjmp	.+14     	; 0x103a <usbPoll+0x14a>
    102c:	88 81       	ld	r24, Y
    102e:	87 fd       	sbrc	r24, 7
    1030:	2e 81       	ldd	r18, Y+6	; 0x06
    1032:	80 e8       	ldi	r24, 0x80	; 128
    1034:	80 93 02 01 	sts	0x0102, r24
    1038:	06 c0       	rjmp	.+12     	; 0x1046 <usbPoll+0x156>
    103a:	8f 81       	ldd	r24, Y+7	; 0x07
    103c:	88 23       	and	r24, r24
    103e:	19 f4       	brne	.+6      	; 0x1046 <usbPoll+0x156>
    1040:	8e 81       	ldd	r24, Y+6	; 0x06
    1042:	82 17       	cp	r24, r18
    1044:	08 f0       	brcs	.+2      	; 0x1048 <usbPoll+0x158>
    1046:	82 2f       	mov	r24, r18
    1048:	80 93 01 01 	sts	0x0101, r24
    104c:	11 c0       	rjmp	.+34     	; 0x1070 <usbPoll+0x180>
    104e:	80 91 02 01 	lds	r24, 0x0102
    1052:	87 ff       	sbrs	r24, 7
    1054:	0d c0       	rjmp	.+26     	; 0x1070 <usbPoll+0x180>
    1056:	ce 01       	movw	r24, r28
    1058:	0e 94 b3 0a 	call	0x1566	; 0x1566 <usbFunctionWrite>
    105c:	8f 3f       	cpi	r24, 0xFF	; 255
    105e:	21 f4       	brne	.+8      	; 0x1068 <usbPoll+0x178>
    1060:	8e e1       	ldi	r24, 0x1E	; 30
    1062:	80 93 00 01 	sts	0x0100, r24
    1066:	04 c0       	rjmp	.+8      	; 0x1070 <usbPoll+0x180>
    1068:	88 23       	and	r24, r24
    106a:	11 f0       	breq	.+4      	; 0x1070 <usbPoll+0x180>
    106c:	10 92 01 01 	sts	0x0101, r1
    1070:	10 92 41 02 	sts	0x0241, r1
    1074:	80 91 00 01 	lds	r24, 0x0100
    1078:	84 ff       	sbrs	r24, 4
    107a:	5a c0       	rjmp	.+180    	; 0x1130 <usbPoll+0x240>
    107c:	80 91 01 01 	lds	r24, 0x0101
    1080:	8f 3f       	cpi	r24, 0xFF	; 255
    1082:	09 f4       	brne	.+2      	; 0x1086 <usbPoll+0x196>
    1084:	55 c0       	rjmp	.+170    	; 0x1130 <usbPoll+0x240>
    1086:	18 2f       	mov	r17, r24
    1088:	89 30       	cpi	r24, 0x09	; 9
    108a:	08 f0       	brcs	.+2      	; 0x108e <usbPoll+0x19e>
    108c:	18 e0       	ldi	r17, 0x08	; 8
    108e:	81 1b       	sub	r24, r17
    1090:	80 93 01 01 	sts	0x0101, r24
    1094:	80 91 24 02 	lds	r24, 0x0224
    1098:	98 e8       	ldi	r25, 0x88	; 136
    109a:	89 27       	eor	r24, r25
    109c:	80 93 24 02 	sts	0x0224, r24
    10a0:	11 23       	and	r17, r17
    10a2:	99 f1       	breq	.+102    	; 0x110a <usbPoll+0x21a>
    10a4:	80 91 02 01 	lds	r24, 0x0102
    10a8:	87 ff       	sbrs	r24, 7
    10aa:	09 c0       	rjmp	.+18     	; 0x10be <usbPoll+0x1ce>
    10ac:	85 e2       	ldi	r24, 0x25	; 37
    10ae:	92 e0       	ldi	r25, 0x02	; 2
    10b0:	61 2f       	mov	r22, r17
    10b2:	0e 94 de 0a 	call	0x15bc	; 0x15bc <usbFunctionRead>
    10b6:	18 2f       	mov	r17, r24
    10b8:	89 30       	cpi	r24, 0x09	; 9
    10ba:	a0 f5       	brcc	.+104    	; 0x1124 <usbPoll+0x234>
    10bc:	26 c0       	rjmp	.+76     	; 0x110a <usbPoll+0x21a>
    10be:	20 91 3f 02 	lds	r18, 0x023F
    10c2:	30 91 40 02 	lds	r19, 0x0240
    10c6:	86 ff       	sbrs	r24, 6
    10c8:	0d c0       	rjmp	.+26     	; 0x10e4 <usbPoll+0x1f4>
    10ca:	a5 e2       	ldi	r26, 0x25	; 37
    10cc:	b2 e0       	ldi	r27, 0x02	; 2
    10ce:	80 e0       	ldi	r24, 0x00	; 0
    10d0:	90 e0       	ldi	r25, 0x00	; 0
    10d2:	f9 01       	movw	r30, r18
    10d4:	e8 0f       	add	r30, r24
    10d6:	f9 1f       	adc	r31, r25
    10d8:	e4 91       	lpm	r30, Z+
    10da:	ed 93       	st	X+, r30
    10dc:	01 96       	adiw	r24, 0x01	; 1
    10de:	18 17       	cp	r17, r24
    10e0:	c1 f7       	brne	.-16     	; 0x10d2 <usbPoll+0x1e2>
    10e2:	08 c0       	rjmp	.+16     	; 0x10f4 <usbPoll+0x204>
    10e4:	d9 01       	movw	r26, r18
    10e6:	91 2f       	mov	r25, r17
    10e8:	e5 e2       	ldi	r30, 0x25	; 37
    10ea:	f2 e0       	ldi	r31, 0x02	; 2
    10ec:	8d 91       	ld	r24, X+
    10ee:	81 93       	st	Z+, r24
    10f0:	91 50       	subi	r25, 0x01	; 1
    10f2:	e1 f7       	brne	.-8      	; 0x10ec <usbPoll+0x1fc>
    10f4:	11 50       	subi	r17, 0x01	; 1
    10f6:	81 2f       	mov	r24, r17
    10f8:	90 e0       	ldi	r25, 0x00	; 0
    10fa:	1f 5f       	subi	r17, 0xFF	; 255
    10fc:	01 96       	adiw	r24, 0x01	; 1
    10fe:	82 0f       	add	r24, r18
    1100:	93 1f       	adc	r25, r19
    1102:	90 93 40 02 	sts	0x0240, r25
    1106:	80 93 3f 02 	sts	0x023F, r24
    110a:	85 e2       	ldi	r24, 0x25	; 37
    110c:	92 e0       	ldi	r25, 0x02	; 2
    110e:	61 2f       	mov	r22, r17
    1110:	0e 94 bb 08 	call	0x1176	; 0x1176 <usbCrc16Append>
    1114:	61 2f       	mov	r22, r17
    1116:	6c 5f       	subi	r22, 0xFC	; 252
    1118:	6c 30       	cpi	r22, 0x0C	; 12
    111a:	41 f0       	breq	.+16     	; 0x112c <usbPoll+0x23c>
    111c:	8f ef       	ldi	r24, 0xFF	; 255
    111e:	80 93 01 01 	sts	0x0101, r24
    1122:	04 c0       	rjmp	.+8      	; 0x112c <usbPoll+0x23c>
    1124:	8f ef       	ldi	r24, 0xFF	; 255
    1126:	80 93 01 01 	sts	0x0101, r24
    112a:	6e e1       	ldi	r22, 0x1E	; 30
    112c:	60 93 00 01 	sts	0x0100, r22
    1130:	94 e1       	ldi	r25, 0x14	; 20
    1132:	89 b1       	in	r24, 0x09	; 9
    1134:	86 70       	andi	r24, 0x06	; 6
    1136:	31 f4       	brne	.+12     	; 0x1144 <usbPoll+0x254>
    1138:	91 50       	subi	r25, 0x01	; 1
    113a:	d9 f7       	brne	.-10     	; 0x1132 <usbPoll+0x242>
    113c:	10 92 42 02 	sts	0x0242, r1
    1140:	10 92 3b 02 	sts	0x023B, r1
    1144:	df 91       	pop	r29
    1146:	cf 91       	pop	r28
    1148:	1f 91       	pop	r17
    114a:	08 95       	ret

0000114c <usbCrc16>:
    114c:	a8 2f       	mov	r26, r24
    114e:	b9 2f       	mov	r27, r25
    1150:	80 e0       	ldi	r24, 0x00	; 0
    1152:	90 e0       	ldi	r25, 0x00	; 0
    1154:	41 e0       	ldi	r20, 0x01	; 1
    1156:	50 ea       	ldi	r21, 0xA0	; 160
    1158:	60 95       	com	r22

0000115a <crcByteLoop>:
    115a:	6f 5f       	subi	r22, 0xFF	; 255
    115c:	58 f4       	brcc	.+22     	; 0x1174 <crcReady>
    115e:	2d 91       	ld	r18, X+
    1160:	38 ef       	ldi	r19, 0xF8	; 248
    1162:	82 27       	eor	r24, r18

00001164 <crcBitLoop>:
    1164:	97 95       	ror	r25
    1166:	87 95       	ror	r24
    1168:	10 f0       	brcs	.+4      	; 0x116e <crcNoXor>
    116a:	84 27       	eor	r24, r20
    116c:	95 27       	eor	r25, r21

0000116e <crcNoXor>:
    116e:	3f 5f       	subi	r19, 0xFF	; 255
    1170:	c8 f3       	brcs	.-14     	; 0x1164 <crcBitLoop>
    1172:	f3 cf       	rjmp	.-26     	; 0x115a <crcByteLoop>

00001174 <crcReady>:
    1174:	08 95       	ret

00001176 <usbCrc16Append>:
    1176:	ea df       	rcall	.-44     	; 0x114c <usbCrc16>
    1178:	8d 93       	st	X+, r24
    117a:	9d 93       	st	X+, r25
    117c:	08 95       	ret

0000117e <__vector_1>:
    117e:	cf 93       	push	r28
    1180:	cf b7       	in	r28, 0x3f	; 63
    1182:	cf 93       	push	r28
    1184:	df 93       	push	r29

00001186 <waitForJ>:
    1186:	c3 95       	inc	r28
    1188:	49 9b       	sbis	0x09, 1	; 9
    118a:	e9 f7       	brne	.-6      	; 0x1186 <waitForJ>

0000118c <waitForK>:
    118c:	49 9b       	sbis	0x09, 1	; 9
    118e:	16 c0       	rjmp	.+44     	; 0x11bc <foundK>
    1190:	49 9b       	sbis	0x09, 1	; 9
    1192:	14 c0       	rjmp	.+40     	; 0x11bc <foundK>
    1194:	49 9b       	sbis	0x09, 1	; 9
    1196:	12 c0       	rjmp	.+36     	; 0x11bc <foundK>
    1198:	49 9b       	sbis	0x09, 1	; 9
    119a:	10 c0       	rjmp	.+32     	; 0x11bc <foundK>
    119c:	49 9b       	sbis	0x09, 1	; 9
    119e:	0e c0       	rjmp	.+28     	; 0x11bc <foundK>
    11a0:	49 9b       	sbis	0x09, 1	; 9
    11a2:	0c c0       	rjmp	.+24     	; 0x11bc <foundK>
    11a4:	49 9b       	sbis	0x09, 1	; 9
    11a6:	0a c0       	rjmp	.+20     	; 0x11bc <foundK>
    11a8:	49 9b       	sbis	0x09, 1	; 9
    11aa:	08 c0       	rjmp	.+16     	; 0x11bc <foundK>
    11ac:	49 9b       	sbis	0x09, 1	; 9
    11ae:	06 c0       	rjmp	.+12     	; 0x11bc <foundK>
    11b0:	c0 91 3e 02 	lds	r28, 0x023E
    11b4:	c3 95       	inc	r28
    11b6:	c0 93 3e 02 	sts	0x023E, r28
    11ba:	83 c0       	rjmp	.+262    	; 0x12c2 <sofError>

000011bc <foundK>:
    11bc:	6f 93       	push	r22
    11be:	c0 91 3d 02 	lds	r28, 0x023D
    11c2:	dd 27       	eor	r29, r29
    11c4:	cb 5b       	subi	r28, 0xBB	; 187
    11c6:	dd 4f       	sbci	r29, 0xFD	; 253
    11c8:	2f 93       	push	r18
    11ca:	20 e4       	ldi	r18, 0x40	; 64
    11cc:	00 c0       	rjmp	.+0      	; 0x11ce <foundK+0x12>
    11ce:	65 e0       	ldi	r22, 0x05	; 5
    11d0:	49 9b       	sbis	0x09, 1	; 9
    11d2:	03 c0       	rjmp	.+6      	; 0x11da <haveTwoBitsK>
    11d4:	2f 91       	pop	r18
    11d6:	6f 91       	pop	r22
    11d8:	d9 cf       	rjmp	.-78     	; 0x118c <waitForK>

000011da <haveTwoBitsK>:
    11da:	0f 93       	push	r16
    11dc:	1f 93       	push	r17
    11de:	4f 93       	push	r20
    11e0:	45 e5       	ldi	r20, 0x55	; 85
    11e2:	5f 93       	push	r21
    11e4:	55 e5       	ldi	r21, 0x55	; 85
    11e6:	3f 93       	push	r19
    11e8:	3b e0       	ldi	r19, 0x0B	; 11
    11ea:	14 e0       	ldi	r17, 0x04	; 4

000011ec <bit0>:
    11ec:	09 b1       	in	r16, 0x09	; 9
    11ee:	06 70       	andi	r16, 0x06	; 6
    11f0:	2e c0       	rjmp	.+92     	; 0x124e <handleBit>

000011f2 <b6checkUnstuff>:
    11f2:	6a 95       	dec	r22
    11f4:	c9 f0       	breq	.+50     	; 0x1228 <unstuff6>

000011f6 <bit7>:
    11f6:	31 50       	subi	r19, 0x01	; 1
    11f8:	d8 f1       	brcs	.+118    	; 0x1270 <overflow>
    11fa:	09 b1       	in	r16, 0x09	; 9
    11fc:	06 70       	andi	r16, 0x06	; 6
    11fe:	01 13       	cpse	r16, r17
    1200:	0b c0       	rjmp	.+22     	; 0x1218 <b7handle0>
    1202:	08 94       	sec
    1204:	27 95       	ror	r18
    1206:	29 93       	st	Y+, r18
    1208:	20 e4       	ldi	r18, 0x40	; 64
    120a:	55 55       	subi	r21, 0x55	; 85
    120c:	00 f4       	brcc	.+0      	; 0x120e <bit7+0x18>
    120e:	6a 95       	dec	r22
    1210:	69 f7       	brne	.-38     	; 0x11ec <bit0>
    1212:	01 e0       	ldi	r16, 0x01	; 1
    1214:	69 b1       	in	r22, 0x09	; 9
    1216:	0b c0       	rjmp	.+22     	; 0x122e <unstuff>

00001218 <b7handle0>:
    1218:	10 2f       	mov	r17, r16
    121a:	66 e0       	ldi	r22, 0x06	; 6
    121c:	26 95       	lsr	r18
    121e:	29 93       	st	Y+, r18
    1220:	20 e4       	ldi	r18, 0x40	; 64
    1222:	55 55       	subi	r21, 0x55	; 85
    1224:	18 f3       	brcs	.-58     	; 0x11ec <bit0>
    1226:	e2 cf       	rjmp	.-60     	; 0x11ec <bit0>

00001228 <unstuff6>:
    1228:	0f ef       	ldi	r16, 0xFF	; 255
    122a:	69 b1       	in	r22, 0x09	; 9
	...

0000122e <unstuff>:
    122e:	16 2f       	mov	r17, r22
    1230:	45 55       	subi	r20, 0x55	; 85
    1232:	00 f0       	brcs	.+0      	; 0x1234 <unstuff+0x6>
    1234:	40 40       	sbci	r20, 0x00	; 0
    1236:	66 e0       	ldi	r22, 0x06	; 6
    1238:	16 70       	andi	r17, 0x06	; 6
    123a:	00 30       	cpi	r16, 0x00	; 0
    123c:	e2 f2       	brmi	.-72     	; 0x11f6 <bit7>
    123e:	21 f0       	breq	.+8      	; 0x1248 <bitloop>
    1240:	00 00       	nop
    1242:	09 b1       	in	r16, 0x09	; 9
    1244:	06 70       	andi	r16, 0x06	; 6
    1246:	03 c0       	rjmp	.+6      	; 0x124e <handleBit>

00001248 <bitloop>:
    1248:	09 b1       	in	r16, 0x09	; 9
    124a:	06 70       	andi	r16, 0x06	; 6
    124c:	a9 f0       	breq	.+42     	; 0x1278 <se0>

0000124e <handleBit>:
    124e:	01 13       	cpse	r16, r17
    1250:	09 c0       	rjmp	.+18     	; 0x1264 <handle0>
    1252:	08 94       	sec
    1254:	27 95       	ror	r18
    1256:	68 f2       	brcs	.-102    	; 0x11f2 <b6checkUnstuff>
    1258:	00 c0       	rjmp	.+0      	; 0x125a <handleBit+0xc>
    125a:	6a 95       	dec	r22
    125c:	a9 f7       	brne	.-22     	; 0x1248 <bitloop>
    125e:	00 e0       	ldi	r16, 0x00	; 0
    1260:	69 b1       	in	r22, 0x09	; 9
    1262:	e5 cf       	rjmp	.-54     	; 0x122e <unstuff>

00001264 <handle0>:
    1264:	10 2f       	mov	r17, r16
    1266:	66 e0       	ldi	r22, 0x06	; 6
    1268:	26 95       	lsr	r18
    126a:	28 f2       	brcs	.-118    	; 0x11f6 <bit7>
    126c:	00 00       	nop
    126e:	ec cf       	rjmp	.-40     	; 0x1248 <bitloop>

00001270 <overflow>:
    1270:	11 e0       	ldi	r17, 0x01	; 1
    1272:	1c bb       	out	0x1c, r17	; 28

00001274 <ignorePacket>:
    1274:	00 27       	eor	r16, r16
    1276:	19 c0       	rjmp	.+50     	; 0x12aa <handleSetupOrOut>

00001278 <se0>:
    1278:	3b 50       	subi	r19, 0x0B	; 11
    127a:	31 95       	neg	r19
    127c:	c3 1b       	sub	r28, r19
    127e:	d0 40       	sbci	r29, 0x00	; 0
    1280:	11 e0       	ldi	r17, 0x01	; 1
    1282:	1c bb       	out	0x1c, r17	; 28
    1284:	08 81       	ld	r16, Y
    1286:	03 3c       	cpi	r16, 0xC3	; 195
    1288:	09 f1       	breq	.+66     	; 0x12cc <handleData>
    128a:	0b 34       	cpi	r16, 0x4B	; 75
    128c:	f9 f0       	breq	.+62     	; 0x12cc <handleData>
    128e:	20 91 3b 02 	lds	r18, 0x023B
    1292:	19 81       	ldd	r17, Y+1	; 0x01
    1294:	11 0f       	add	r17, r17
    1296:	12 13       	cpse	r17, r18
    1298:	ed cf       	rjmp	.-38     	; 0x1274 <ignorePacket>
    129a:	4a 81       	ldd	r20, Y+2	; 0x02
    129c:	44 1f       	adc	r20, r20
    129e:	09 36       	cpi	r16, 0x69	; 105
    12a0:	51 f1       	breq	.+84     	; 0x12f6 <handleIn>
    12a2:	0d 32       	cpi	r16, 0x2D	; 45
    12a4:	11 f0       	breq	.+4      	; 0x12aa <handleSetupOrOut>
    12a6:	01 3e       	cpi	r16, 0xE1	; 225
    12a8:	29 f7       	brne	.-54     	; 0x1274 <ignorePacket>

000012aa <handleSetupOrOut>:
    12aa:	00 93 43 02 	sts	0x0243, r16

000012ae <doReturn>:
    12ae:	3f 91       	pop	r19
    12b0:	5f 91       	pop	r21
    12b2:	4f 91       	pop	r20
    12b4:	1f 91       	pop	r17
    12b6:	0f 91       	pop	r16
    12b8:	2f 91       	pop	r18
    12ba:	6f 91       	pop	r22
    12bc:	cc b3       	in	r28, 0x1c	; 28
    12be:	c0 fd       	sbrc	r28, 0
    12c0:	62 cf       	rjmp	.-316    	; 0x1186 <waitForJ>

000012c2 <sofError>:
    12c2:	df 91       	pop	r29
    12c4:	cf 91       	pop	r28
    12c6:	cf bf       	out	0x3f, r28	; 63
    12c8:	cf 91       	pop	r28
    12ca:	18 95       	reti

000012cc <handleData>:
    12cc:	20 91 43 02 	lds	r18, 0x0243
    12d0:	22 23       	and	r18, r18
    12d2:	69 f3       	breq	.-38     	; 0x12ae <doReturn>
    12d4:	10 91 41 02 	lds	r17, 0x0241
    12d8:	11 23       	and	r17, r17
    12da:	81 f5       	brne	.+96     	; 0x133c <sendNakAndReti>
    12dc:	34 30       	cpi	r19, 0x04	; 4
    12de:	82 f1       	brmi	.+96     	; 0x1340 <sendAckAndReti>
    12e0:	30 93 41 02 	sts	0x0241, r19
    12e4:	20 93 3c 02 	sts	0x023C, r18
    12e8:	10 91 3d 02 	lds	r17, 0x023D
    12ec:	3b e0       	ldi	r19, 0x0B	; 11
    12ee:	31 1b       	sub	r19, r17
    12f0:	30 93 3d 02 	sts	0x023D, r19
    12f4:	25 c0       	rjmp	.+74     	; 0x1340 <sendAckAndReti>

000012f6 <handleIn>:
    12f6:	00 91 41 02 	lds	r16, 0x0241
    12fa:	01 30       	cpi	r16, 0x01	; 1
    12fc:	fc f4       	brge	.+62     	; 0x133c <sendNakAndReti>
    12fe:	0a e5       	ldi	r16, 0x5A	; 90
    1300:	4f 70       	andi	r20, 0x0F	; 15
    1302:	49 f4       	brne	.+18     	; 0x1316 <handleIn1>
    1304:	30 91 00 01 	lds	r19, 0x0100
    1308:	34 fd       	sbrc	r19, 4
    130a:	1b c0       	rjmp	.+54     	; 0x1342 <sendCntAndReti>
    130c:	00 93 00 01 	sts	0x0100, r16
    1310:	c4 e2       	ldi	r28, 0x24	; 36
    1312:	d2 e0       	ldi	r29, 0x02	; 2
    1314:	1a c0       	rjmp	.+52     	; 0x134a <usbSendAndReti>

00001316 <handleIn1>:
    1316:	30 91 2f 02 	lds	r19, 0x022F
    131a:	34 fd       	sbrc	r19, 4
    131c:	12 c0       	rjmp	.+36     	; 0x1342 <sendCntAndReti>
    131e:	00 93 2f 02 	sts	0x022F, r16
    1322:	c0 e3       	ldi	r28, 0x30	; 48
    1324:	d2 e0       	ldi	r29, 0x02	; 2
    1326:	11 c0       	rjmp	.+34     	; 0x134a <usbSendAndReti>

00001328 <bitstuffN>:
    1328:	05 27       	eor	r16, r21
    132a:	10 e0       	ldi	r17, 0x00	; 0
    132c:	00 c0       	rjmp	.+0      	; 0x132e <bitstuffN+0x6>
    132e:	0b b9       	out	0x0b, r16	; 11
    1330:	19 c0       	rjmp	.+50     	; 0x1364 <didStuffN>

00001332 <bitstuff7>:
    1332:	05 27       	eor	r16, r21
    1334:	10 e0       	ldi	r17, 0x00	; 0
    1336:	22 1f       	adc	r18, r18
    1338:	00 c0       	rjmp	.+0      	; 0x133a <bitstuff7+0x8>
    133a:	1d c0       	rjmp	.+58     	; 0x1376 <didStuff7>

0000133c <sendNakAndReti>:
    133c:	4a e5       	ldi	r20, 0x5A	; 90
    133e:	02 c0       	rjmp	.+4      	; 0x1344 <sendX3AndReti>

00001340 <sendAckAndReti>:
    1340:	32 ed       	ldi	r19, 0xD2	; 210

00001342 <sendCntAndReti>:
    1342:	43 2f       	mov	r20, r19

00001344 <sendX3AndReti>:
    1344:	c4 e1       	ldi	r28, 0x14	; 20
    1346:	d0 e0       	ldi	r29, 0x00	; 0
    1348:	32 e0       	ldi	r19, 0x02	; 2

0000134a <usbSendAndReti>:
    134a:	1a b1       	in	r17, 0x0a	; 10
    134c:	16 60       	ori	r17, 0x06	; 6
    134e:	59 9a       	sbi	0x0b, 1	; 11
    1350:	0b b1       	in	r16, 0x0b	; 11
    1352:	1a b9       	out	0x0a, r17	; 10
    1354:	56 e0       	ldi	r21, 0x06	; 6
    1356:	20 e8       	ldi	r18, 0x80	; 128

00001358 <txByteLoop>:
    1358:	69 e4       	ldi	r22, 0x49	; 73

0000135a <txBitLoop>:
    135a:	20 ff       	sbrs	r18, 0
    135c:	05 27       	eor	r16, r21
    135e:	0b b9       	out	0x0b, r16	; 11
    1360:	27 95       	ror	r18
    1362:	17 95       	ror	r17

00001364 <didStuffN>:
    1364:	00 c0       	rjmp	.+0      	; 0x1366 <didStuffN+0x2>
    1366:	00 00       	nop
    1368:	1c 3f       	cpi	r17, 0xFC	; 252
    136a:	f0 f6       	brcc	.-68     	; 0x1328 <bitstuffN>
    136c:	66 95       	lsr	r22
    136e:	a8 f7       	brcc	.-22     	; 0x135a <txBitLoop>
    1370:	a1 f7       	brne	.-24     	; 0x135a <txBitLoop>
    1372:	20 ff       	sbrs	r18, 0
    1374:	05 27       	eor	r16, r21

00001376 <didStuff7>:
    1376:	0b b9       	out	0x0b, r16	; 11
    1378:	27 95       	ror	r18
    137a:	17 95       	ror	r17
    137c:	00 00       	nop
    137e:	1c 3f       	cpi	r17, 0xFC	; 252
    1380:	c0 f6       	brcc	.-80     	; 0x1332 <bitstuff7>
    1382:	29 91       	ld	r18, Y+
    1384:	3a 95       	dec	r19
    1386:	41 f7       	brne	.-48     	; 0x1358 <txByteLoop>
    1388:	09 7f       	andi	r16, 0xF9	; 249
    138a:	10 91 42 02 	lds	r17, 0x0242
    138e:	11 0f       	add	r17, r17
    1390:	0b b9       	out	0x0b, r16	; 11
    1392:	c6 51       	subi	r28, 0x16	; 22
    1394:	d0 40       	sbci	r29, 0x00	; 0
    1396:	11 f0       	breq	.+4      	; 0x139c <skipAddrAssign>
    1398:	10 93 3b 02 	sts	0x023B, r17

0000139c <skipAddrAssign>:
    139c:	11 e0       	ldi	r17, 0x01	; 1
    139e:	1c bb       	out	0x1c, r17	; 28
    13a0:	02 60       	ori	r16, 0x02	; 2
    13a2:	1a b1       	in	r17, 0x0a	; 10
    13a4:	19 7f       	andi	r17, 0xF9	; 249
    13a6:	40 2f       	mov	r20, r16
    13a8:	49 7f       	andi	r20, 0xF9	; 249
    13aa:	55 e0       	ldi	r21, 0x05	; 5

000013ac <se0Delay>:
    13ac:	5a 95       	dec	r21
    13ae:	f1 f7       	brne	.-4      	; 0x13ac <se0Delay>
    13b0:	0b b9       	out	0x0b, r16	; 11
    13b2:	1a b9       	out	0x0a, r17	; 10
    13b4:	4b b9       	out	0x0b, r20	; 11
    13b6:	7b cf       	rjmp	.-266    	; 0x12ae <doReturn>

000013b8 <setup_timers>:
#include "header.h"

void setup_timers()
{
	//setup timer 0 for USB pooling
	TCCR0A = (1<<WGM01);
    13b8:	92 e0       	ldi	r25, 0x02	; 2
    13ba:	94 bd       	out	0x24, r25	; 36
	TCCR0B = (1<<CS00)|(1<<CS02); //Clock source = CLK_IO / 1024
    13bc:	85 e0       	ldi	r24, 0x05	; 5
    13be:	85 bd       	out	0x25, r24	; 37
	OCR0A = 24;//194; //Configuration for 50 Hz interrupt source
    13c0:	88 e1       	ldi	r24, 0x18	; 24
    13c2:	87 bd       	out	0x27, r24	; 39
	TIMSK0 = (1<<OCIE0A);
    13c4:	90 93 6e 00 	sts	0x006E, r25

	//Setup timer 1 for timestamping
	TCCR1A = 0;	//no waveform generation
    13c8:	10 92 80 00 	sts	0x0080, r1
	STOP_TIMER1	//Timer is started by "START_TIMER1" at the right moment.
    13cc:	10 92 81 00 	sts	0x0081, r1
	TIMSK1 = (1<<TOIE1);
    13d0:	81 e0       	ldi	r24, 0x01	; 1
    13d2:	80 93 6f 00 	sts	0x006F, r24

	//SETUP TIMER 2 for clock generation
	STOP_TIMER2;//Timer is started by "START_TIMER2" when needed
    13d6:	10 92 b0 00 	sts	0x00B0, r1
    13da:	10 92 b1 00 	sts	0x00B1, r1
    13de:	23 9a       	sbi	0x04, 3	; 4
    13e0:	2b 98       	cbi	0x05, 3	; 5
}
    13e2:	08 95       	ret

000013e4 <setup_trigger>:


void setup_trigger(uchar mask)
{
	PCICR  = (1<<PCIE1);	//enable Pin change interrupt on pins 
    13e4:	92 e0       	ldi	r25, 0x02	; 2
    13e6:	90 93 68 00 	sts	0x0068, r25
	PCMSK1 = mask; //Set the mask on the four sampling inputs according to user request
    13ea:	80 93 6c 00 	sts	0x006C, r24
}
    13ee:	08 95       	ret

000013f0 <__vector_13>:
}*/



ISR(TIMER1_OVF_vect,ISR_NOBLOCK)
{
    13f0:	78 94       	sei
    13f2:	1f 92       	push	r1
    13f4:	0f 92       	push	r0
    13f6:	0f b6       	in	r0, 0x3f	; 63
    13f8:	0f 92       	push	r0
    13fa:	11 24       	eor	r1, r1
    13fc:	8f 93       	push	r24
    13fe:	9f 93       	push	r25
	
	timer1_post_scaller++;
    1400:	80 91 19 02 	lds	r24, 0x0219
    1404:	90 91 1a 02 	lds	r25, 0x021A
    1408:	01 96       	adiw	r24, 0x01	; 1
    140a:	90 93 1a 02 	sts	0x021A, r25
    140e:	80 93 19 02 	sts	0x0219, r24
	//LED_ON;
}
    1412:	9f 91       	pop	r25
    1414:	8f 91       	pop	r24
    1416:	0f 90       	pop	r0
    1418:	0f be       	out	0x3f, r0	; 63
    141a:	0f 90       	pop	r0
    141c:	1f 90       	pop	r1
    141e:	18 95       	reti

00001420 <__vector_4>:

ISR(PCINT1_vect,ISR_NAKED)
{
	//
//	uchar i,valid_low,;
	asm("push R24");
    1420:	8f 93       	push	r24
	stream[136] = PINC;
    1422:	86 b1       	in	r24, 0x06	; 6
    1424:	80 93 ad 01 	sts	0x01AD, r24
	asm("IN R0,0x3F"); //save SREG
    1428:	0f b6       	in	r0, 0x3f	; 63
	asm("push R0");
    142a:	0f 92       	push	r0
	asm("push R1");
    142c:	1f 92       	push	r1
	stream[135] ++;
    142e:	80 91 ac 01 	lds	r24, 0x01AC
    1432:	8f 5f       	subi	r24, 0xFF	; 255
    1434:	80 93 ac 01 	sts	0x01AC, r24
	if (stream[135] > 1) PCMSK1 = 0x0;
    1438:	80 91 ac 01 	lds	r24, 0x01AC
    143c:	82 30       	cpi	r24, 0x02	; 2
    143e:	10 f0       	brcs	.+4      	; 0x1444 <__vector_4+0x24>
    1440:	10 92 6c 00 	sts	0x006C, r1
	//
	//uchar sreg_bruk = SREG;
	//cli();
	
	asm("pop R1");
    1444:	1f 90       	pop	r1
	asm("pop R0");
    1446:	0f 90       	pop	r0
	asm("out 0x3F,R0");
    1448:	0f be       	out	0x3f, r0	; 63
	asm("pop R24");
    144a:	8f 91       	pop	r24
	//sei();
	//SREG = sreg_bruk;
	reti();
    144c:	18 95       	reti

0000144e <__vector_14>:

#include "header.h"


ISR(TIMER0_COMPA_vect,ISR_NOBLOCK)
{
    144e:	78 94       	sei
    1450:	1f 92       	push	r1
    1452:	0f 92       	push	r0
    1454:	0f b6       	in	r0, 0x3f	; 63
    1456:	0f 92       	push	r0
    1458:	11 24       	eor	r1, r1
    145a:	2f 93       	push	r18
    145c:	3f 93       	push	r19
    145e:	4f 93       	push	r20
    1460:	5f 93       	push	r21
    1462:	6f 93       	push	r22
    1464:	7f 93       	push	r23
    1466:	8f 93       	push	r24
    1468:	9f 93       	push	r25
    146a:	af 93       	push	r26
    146c:	bf 93       	push	r27
    146e:	ef 93       	push	r30
    1470:	ff 93       	push	r31
	//Executed at 50Hz
 usbPoll();
    1472:	0e 94 78 07 	call	0xef0	; 0xef0 <usbPoll>

 if (new_usb_data == 1)
    1476:	80 91 0f 02 	lds	r24, 0x020F
    147a:	81 30       	cpi	r24, 0x01	; 1
    147c:	09 f0       	breq	.+2      	; 0x1480 <__vector_14+0x32>
    147e:	4d c0       	rjmp	.+154    	; 0x151a <__vector_14+0xcc>
	{
		new_usb_data = 0;
    1480:	10 92 0f 02 	sts	0x020F, r1
		pc_connected = 1;
    1484:	80 93 14 02 	sts	0x0214, r24
		switch(stream[0])
    1488:	90 91 25 01 	lds	r25, 0x0125
    148c:	98 30       	cpi	r25, 0x08	; 8
    148e:	f1 f0       	breq	.+60     	; 0x14cc <__vector_14+0x7e>
    1490:	99 30       	cpi	r25, 0x09	; 9
    1492:	60 f4       	brcc	.+24     	; 0x14ac <__vector_14+0x5e>
    1494:	92 30       	cpi	r25, 0x02	; 2
    1496:	b9 f1       	breq	.+110    	; 0x1506 <__vector_14+0xb8>
    1498:	93 30       	cpi	r25, 0x03	; 3
    149a:	18 f4       	brcc	.+6      	; 0x14a2 <__vector_14+0x54>
    149c:	91 30       	cpi	r25, 0x01	; 1
    149e:	e9 f5       	brne	.+122    	; 0x151a <__vector_14+0xcc>
    14a0:	0e c0       	rjmp	.+28     	; 0x14be <__vector_14+0x70>
    14a2:	96 30       	cpi	r25, 0x06	; 6
    14a4:	39 f1       	breq	.+78     	; 0x14f4 <__vector_14+0xa6>
    14a6:	97 30       	cpi	r25, 0x07	; 7
    14a8:	c1 f5       	brne	.+112    	; 0x151a <__vector_14+0xcc>
    14aa:	24 c0       	rjmp	.+72     	; 0x14f4 <__vector_14+0xa6>
    14ac:	9a 30       	cpi	r25, 0x0A	; 10
    14ae:	89 f1       	breq	.+98     	; 0x1512 <__vector_14+0xc4>
    14b0:	9a 30       	cpi	r25, 0x0A	; 10
    14b2:	30 f1       	brcs	.+76     	; 0x1500 <__vector_14+0xb2>
    14b4:	9b 30       	cpi	r25, 0x0B	; 11
    14b6:	09 f1       	breq	.+66     	; 0x14fa <__vector_14+0xac>
    14b8:	9c 30       	cpi	r25, 0x0C	; 12
    14ba:	79 f5       	brne	.+94     	; 0x151a <__vector_14+0xcc>
    14bc:	05 c0       	rjmp	.+10     	; 0x14c8 <__vector_14+0x7a>
		{
			case USB_SEQUENCE_CONFIG:
				
				//memset	((void*)(&stream[0]),0,128); //clear the data stream
				if (state_machine ==0)
    14be:	80 91 23 01 	lds	r24, 0x0123
    14c2:	88 23       	and	r24, r24
    14c4:	51 f5       	brne	.+84     	; 0x151a <__vector_14+0xcc>
    14c6:	16 c0       	rjmp	.+44     	; 0x14f4 <__vector_14+0xa6>
			case USB_SEQUENCE_LIVE_MODE:
				state_machine = 6;
			break;
				
			case USB_CLR_SRAMS:
					state_machine = 98;
    14c8:	82 e6       	ldi	r24, 0x62	; 98
    14ca:	20 c0       	rjmp	.+64     	; 0x150c <__vector_14+0xbe>
			break;

			case USB_UPDATE_START:
				//start a new sequencial write at address 0
				ISOLATE_PROBES;
    14cc:	21 9a       	sbi	0x04, 1	; 4
    14ce:	29 9a       	sbi	0x05, 1	; 5
    14d0:	20 9a       	sbi	0x04, 0	; 4
    14d2:	28 9a       	sbi	0x05, 0	; 5
    14d4:	22 9a       	sbi	0x04, 2	; 4
    14d6:	2a 9a       	sbi	0x05, 2	; 5
    14d8:	24 9a       	sbi	0x04, 4	; 4
    14da:	2c 9a       	sbi	0x05, 4	; 5
				update_channel = stream[1];		
    14dc:	80 91 26 01 	lds	r24, 0x0126
    14e0:	80 93 11 02 	sts	0x0211, r24
				//sram_mixed_setup(INST_WRITE, INST_WRITE, 0);
				sram_single_setup(INST_WRITE, update_channel, 0);
    14e4:	60 91 11 02 	lds	r22, 0x0211
    14e8:	82 e0       	ldi	r24, 0x02	; 2
    14ea:	40 e0       	ldi	r20, 0x00	; 0
    14ec:	50 e0       	ldi	r21, 0x00	; 0
    14ee:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <sram_single_setup>
    14f2:	13 c0       	rjmp	.+38     	; 0x151a <__vector_14+0xcc>
			break;
			case USB_UPDATE:
				state_machine = 7;
    14f4:	90 93 23 01 	sts	0x0123, r25
    14f8:	10 c0       	rjmp	.+32     	; 0x151a <__vector_14+0xcc>
			break;
			case USB_END_SEQUENCE:
				sram_cs_end(); //Stop the SRAM sequence
    14fa:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <sram_cs_end>
    14fe:	0d c0       	rjmp	.+26     	; 0x151a <__vector_14+0xcc>
			break;
			case USB_UPDATE_BOOT:
				//sram_internal_clk(0x0, 0xFF,0xFF); // alow SPM
				//sram_internal_clk(0x10, 0xFF,0xFF); // alow SPM in app section
				bootloader();
    1500:	0e 94 36 1e 	call	0x3c6c	; 0x3c6c <bootloader>
    1504:	0a c0       	rjmp	.+20     	; 0x151a <__vector_14+0xcc>
			break;
			case USB_SEQUENCE_ABORT: //***************************************************
				abort_sequence = 1;
    1506:	80 93 1e 01 	sts	0x011E, r24
				state_machine = 99;
    150a:	83 e6       	ldi	r24, 0x63	; 99
    150c:	80 93 23 01 	sts	0x0123, r24
    1510:	04 c0       	rjmp	.+8      	; 0x151a <__vector_14+0xcc>
			break;
			case USB_GET_SN:
				state_machine = USB_GET_SN;
    1512:	90 93 23 01 	sts	0x0123, r25
				usb_data_read = 0;
    1516:	10 92 04 01 	sts	0x0104, r1
		}

 
	}//end of new_usb_data

}
    151a:	ff 91       	pop	r31
    151c:	ef 91       	pop	r30
    151e:	bf 91       	pop	r27
    1520:	af 91       	pop	r26
    1522:	9f 91       	pop	r25
    1524:	8f 91       	pop	r24
    1526:	7f 91       	pop	r23
    1528:	6f 91       	pop	r22
    152a:	5f 91       	pop	r21
    152c:	4f 91       	pop	r20
    152e:	3f 91       	pop	r19
    1530:	2f 91       	pop	r18
    1532:	0f 90       	pop	r0
    1534:	0f be       	out	0x3f, r0	; 63
    1536:	0f 90       	pop	r0
    1538:	1f 90       	pop	r1
    153a:	18 95       	reti

0000153c <usbFunctionSetup>:

/* ------------------------------------------------------------------------- */

usbMsgLen_t usbFunctionSetup(uchar data[8])
{
usbRequest_t    *rq = (void *)data;
    153c:	fc 01       	movw	r30, r24
		usb_alive = 0;
    153e:	10 92 07 01 	sts	0x0107, r1
    if((rq->bmRequestType & USBRQ_TYPE_MASK) == USBRQ_TYPE_CLASS){    /* HID class request */
    1542:	80 81       	ld	r24, Z
    1544:	80 76       	andi	r24, 0x60	; 96
    1546:	80 32       	cpi	r24, 0x20	; 32
    1548:	61 f4       	brne	.+24     	; 0x1562 <usbFunctionSetup+0x26>
        if(rq->bRequest == USBRQ_HID_GET_REPORT){  /* wValue: ReportType (highbyte), ReportID (lowbyte) */
    154a:	81 81       	ldd	r24, Z+1	; 0x01
    154c:	81 30       	cpi	r24, 0x01	; 1
    154e:	11 f0       	breq	.+4      	; 0x1554 <usbFunctionSetup+0x18>
            /* since we have only one report type, we can ignore the report-ID */
            bytesRemaining = 128;
            currentAddress = 0;
            return USB_NO_MSG;  /* use usbFunctionRead() to obtain data */
        }else if(rq->bRequest == USBRQ_HID_SET_REPORT){
    1550:	89 30       	cpi	r24, 0x09	; 9
    1552:	39 f4       	brne	.+14     	; 0x1562 <usbFunctionSetup+0x26>
            /* since we have only one report type, we can ignore the report-ID */
            bytesRemaining = 128;
    1554:	80 e8       	ldi	r24, 0x80	; 128
    1556:	80 93 19 01 	sts	0x0119, r24
            currentAddress = 0;
    155a:	10 92 18 01 	sts	0x0118, r1
    155e:	8f ef       	ldi	r24, 0xFF	; 255
    1560:	08 95       	ret
            return USB_NO_MSG;  /* use usbFunctionWrite() to receive data from host */
    1562:	80 e0       	ldi	r24, 0x00	; 0
        }
    }else{
        /* ignore vendor type requests, we don't use any */
    }
    return 0;
}
    1564:	08 95       	ret

00001566 <usbFunctionWrite>:

/* usbFunctionWrite() is called when the host sends a chunk of data to the
 * device. For more information see the documentation in usbdrv/usbdrv.h.
 */
uchar   usbFunctionWrite(uchar *data, uchar len)
{
    1566:	1f 93       	push	r17
    1568:	58 2f       	mov	r21, r24
    156a:	79 2f       	mov	r23, r25
		usb_alive = 0;
    156c:	10 92 07 01 	sts	0x0107, r1
    if(bytesRemaining == 0)
    1570:	80 91 19 01 	lds	r24, 0x0119
    1574:	88 23       	and	r24, r24
    1576:	e9 f0       	breq	.+58     	; 0x15b2 <usbFunctionWrite+0x4c>
		{
				new_usb_data = 1;			// ADDED BY IKALOGIC
        return 1;               /* end of transfer */
    1578:	16 2f       	mov	r17, r22
    157a:	86 17       	cp	r24, r22
    157c:	08 f4       	brcc	.+2      	; 0x1580 <usbFunctionWrite+0x1a>
    157e:	18 2f       	mov	r17, r24
		}
    if(len > bytesRemaining)
        len = bytesRemaining;
    //eeprom_write_block(data, (uchar *)0 + currentAddress, len);
		memcpy ((uchar *)stream+currentAddress,data,len);
    1580:	20 91 18 01 	lds	r18, 0x0118
    1584:	30 e0       	ldi	r19, 0x00	; 0
    1586:	2b 5d       	subi	r18, 0xDB	; 219
    1588:	3e 4f       	sbci	r19, 0xFE	; 254
    158a:	c9 01       	movw	r24, r18
    158c:	65 2f       	mov	r22, r21
    158e:	41 2f       	mov	r20, r17
    1590:	50 e0       	ldi	r21, 0x00	; 0
    1592:	0e 94 23 0b 	call	0x1646	; 0x1646 <memcpy>
    currentAddress += len;
    1596:	80 91 18 01 	lds	r24, 0x0118
    159a:	81 0f       	add	r24, r17
    159c:	80 93 18 01 	sts	0x0118, r24
    bytesRemaining -= len;
    15a0:	80 91 19 01 	lds	r24, 0x0119
    15a4:	81 1b       	sub	r24, r17
    15a6:	80 93 19 01 	sts	0x0119, r24
    //return bytesRemaining == 0; /* return 1 if this was the last chunk */

		// ADDED BY IKALOGIC
		if(bytesRemaining == 0)
    15aa:	88 23       	and	r24, r24
    15ac:	11 f0       	breq	.+4      	; 0x15b2 <usbFunctionWrite+0x4c>
    15ae:	80 e0       	ldi	r24, 0x00	; 0
    15b0:	03 c0       	rjmp	.+6      	; 0x15b8 <usbFunctionWrite+0x52>
		{
				new_usb_data = 1;
    15b2:	81 e0       	ldi	r24, 0x01	; 1
    15b4:	80 93 0f 02 	sts	0x020F, r24
        return 1;               /* end of transfer */
		}
		return bytesRemaining == 0;
}
    15b8:	1f 91       	pop	r17
    15ba:	08 95       	ret

000015bc <usbFunctionRead>:

/* usbFunctionRead() is called when the host requests a chunk of data from
 * the device. For more information see the documentation in usbdrv/usbdrv.h.
 */
uchar   usbFunctionRead(uchar *data, uchar len) //sends data to HOST
{
    15bc:	1f 93       	push	r17
    15be:	20 91 19 01 	lds	r18, 0x0119
    15c2:	16 2f       	mov	r17, r22
    15c4:	26 17       	cp	r18, r22
    15c6:	08 f4       	brcc	.+2      	; 0x15ca <usbFunctionRead+0xe>
    15c8:	12 2f       	mov	r17, r18
        len = bytesRemaining;
		////eeprom_write_block((uchar *)stream, (uchar *)0 + currentAddress, len);
    //	eeprom_read_block(data, (uchar *)0 + currentAddress, len);
		//memset(data,0xDD,len);
		//data = 0;
		memcpy (data,(uchar *)stream+currentAddress,len);
    15ca:	20 91 18 01 	lds	r18, 0x0118
    15ce:	30 e0       	ldi	r19, 0x00	; 0
    15d0:	2b 5d       	subi	r18, 0xDB	; 219
    15d2:	3e 4f       	sbci	r19, 0xFE	; 254
    15d4:	b9 01       	movw	r22, r18
    15d6:	41 2f       	mov	r20, r17
    15d8:	50 e0       	ldi	r21, 0x00	; 0
    15da:	0e 94 23 0b 	call	0x1646	; 0x1646 <memcpy>
    currentAddress += len;
    15de:	80 91 18 01 	lds	r24, 0x0118
    15e2:	81 0f       	add	r24, r17
    15e4:	80 93 18 01 	sts	0x0118, r24
    bytesRemaining -= len;
    15e8:	80 91 19 01 	lds	r24, 0x0119
    15ec:	81 1b       	sub	r24, r17
    15ee:	80 93 19 01 	sts	0x0119, r24
		if (bytesRemaining == 0)
    15f2:	88 23       	and	r24, r24
    15f4:	19 f4       	brne	.+6      	; 0x15fc <usbFunctionRead+0x40>
		{
			usb_data_read = 1;
    15f6:	81 e0       	ldi	r24, 0x01	; 1
    15f8:	80 93 04 01 	sts	0x0104, r24
			
		}
    return len;
}
    15fc:	81 2f       	mov	r24, r17
    15fe:	1f 91       	pop	r17
    1600:	08 95       	ret

00001602 <__udivmodsi4>:
    1602:	a1 e2       	ldi	r26, 0x21	; 33
    1604:	1a 2e       	mov	r1, r26
    1606:	aa 1b       	sub	r26, r26
    1608:	bb 1b       	sub	r27, r27
    160a:	fd 01       	movw	r30, r26
    160c:	0d c0       	rjmp	.+26     	; 0x1628 <__udivmodsi4_ep>

0000160e <__udivmodsi4_loop>:
    160e:	aa 1f       	adc	r26, r26
    1610:	bb 1f       	adc	r27, r27
    1612:	ee 1f       	adc	r30, r30
    1614:	ff 1f       	adc	r31, r31
    1616:	a2 17       	cp	r26, r18
    1618:	b3 07       	cpc	r27, r19
    161a:	e4 07       	cpc	r30, r20
    161c:	f5 07       	cpc	r31, r21
    161e:	20 f0       	brcs	.+8      	; 0x1628 <__udivmodsi4_ep>
    1620:	a2 1b       	sub	r26, r18
    1622:	b3 0b       	sbc	r27, r19
    1624:	e4 0b       	sbc	r30, r20
    1626:	f5 0b       	sbc	r31, r21

00001628 <__udivmodsi4_ep>:
    1628:	66 1f       	adc	r22, r22
    162a:	77 1f       	adc	r23, r23
    162c:	88 1f       	adc	r24, r24
    162e:	99 1f       	adc	r25, r25
    1630:	1a 94       	dec	r1
    1632:	69 f7       	brne	.-38     	; 0x160e <__udivmodsi4_loop>
    1634:	60 95       	com	r22
    1636:	70 95       	com	r23
    1638:	80 95       	com	r24
    163a:	90 95       	com	r25
    163c:	9b 01       	movw	r18, r22
    163e:	ac 01       	movw	r20, r24
    1640:	bd 01       	movw	r22, r26
    1642:	cf 01       	movw	r24, r30
    1644:	08 95       	ret

00001646 <memcpy>:
    1646:	fb 01       	movw	r30, r22
    1648:	dc 01       	movw	r26, r24
    164a:	02 c0       	rjmp	.+4      	; 0x1650 <memcpy+0xa>
    164c:	01 90       	ld	r0, Z+
    164e:	0d 92       	st	X+, r0
    1650:	41 50       	subi	r20, 0x01	; 1
    1652:	50 40       	sbci	r21, 0x00	; 0
    1654:	d8 f7       	brcc	.-10     	; 0x164c <memcpy+0x6>
    1656:	08 95       	ret

00001658 <memset>:
    1658:	dc 01       	movw	r26, r24
    165a:	01 c0       	rjmp	.+2      	; 0x165e <memset+0x6>
    165c:	6d 93       	st	X+, r22
    165e:	41 50       	subi	r20, 0x01	; 1
    1660:	50 40       	sbci	r21, 0x00	; 0
    1662:	e0 f7       	brcc	.-8      	; 0x165c <memset+0x4>
    1664:	08 95       	ret

00001666 <__eerd_byte_m168>:
    1666:	f9 99       	sbic	0x1f, 1	; 31
    1668:	fe cf       	rjmp	.-4      	; 0x1666 <__eerd_byte_m168>
    166a:	92 bd       	out	0x22, r25	; 34
    166c:	81 bd       	out	0x21, r24	; 33
    166e:	f8 9a       	sbi	0x1f, 0	; 31
    1670:	99 27       	eor	r25, r25
    1672:	80 b5       	in	r24, 0x20	; 32
    1674:	08 95       	ret

00001676 <_exit>:
    1676:	f8 94       	cli

00001678 <__stop_program>:
    1678:	ff cf       	rjmp	.-2      	; 0x1678 <__stop_program>

Disassembly of section .bootloader:

00003800 <sram_out>:

BOOTLOADER_SECTION void sram_out(uchar val,uchar channel)
{
	//	DECRIPTION : Lowest level function used by intermediate level functions.
	//	Used to set/clear the MISO line of the SRAM defines by "channel"
	if (channel == CH_ALL)
    3800:	63 36       	cpi	r22, 0x63	; 99
    3802:	91 f4       	brne	.+36     	; 0x3828 <sram_out+0x28>
	{
		switch(val)
    3804:	88 23       	and	r24, r24
    3806:	19 f0       	breq	.+6      	; 0x380e <sram_out+0xe>
    3808:	81 30       	cpi	r24, 0x01	; 1
    380a:	89 f5       	brne	.+98     	; 0x386e <sram_out+0x6e>
    380c:	06 c0       	rjmp	.+12     	; 0x381a <sram_out+0x1a>
		{
			case 0: //Hard low level
				DDR_MOSI |= MOSI_MASK;				//set all pins as output
    380e:	87 b1       	in	r24, 0x07	; 7
    3810:	8f 60       	ori	r24, 0x0F	; 15
    3812:	87 b9       	out	0x07, r24	; 7
				PORT_MOSI &= ~(MOSI_MASK);		//set all pins low
    3814:	88 b1       	in	r24, 0x08	; 8
    3816:	80 7f       	andi	r24, 0xF0	; 240
    3818:	05 c0       	rjmp	.+10     	; 0x3824 <sram_out+0x24>
			break;
			case 1:	//Soft high level via pull-ups (to respect 3V6 SRAM level)
				DDR_MOSI &= ~(MOSI_MASK);		//set all pins as inputs
    381a:	87 b1       	in	r24, 0x07	; 7
    381c:	80 7f       	andi	r24, 0xF0	; 240
    381e:	87 b9       	out	0x07, r24	; 7
				PORT_MOSI |= MOSI_MASK;		//Activate pull-up on all pins
    3820:	88 b1       	in	r24, 0x08	; 8
    3822:	8f 60       	ori	r24, 0x0F	; 15
    3824:	88 b9       	out	0x08, r24	; 8
    3826:	08 95       	ret
			break;
			default:
			break;
		}
	}else{
		switch(val)
    3828:	88 23       	and	r24, r24
    382a:	19 f0       	breq	.+6      	; 0x3832 <sram_out+0x32>
    382c:	81 30       	cpi	r24, 0x01	; 1
    382e:	f9 f4       	brne	.+62     	; 0x386e <sram_out+0x6e>
    3830:	0f c0       	rjmp	.+30     	; 0x3850 <sram_out+0x50>
		{
			case 0: //Hard low level
				DDR_MOSI |= (1<<(channel));				//set all pins as output
    3832:	87 b1       	in	r24, 0x07	; 7
    3834:	21 e0       	ldi	r18, 0x01	; 1
    3836:	30 e0       	ldi	r19, 0x00	; 0
    3838:	02 c0       	rjmp	.+4      	; 0x383e <sram_out+0x3e>
    383a:	22 0f       	add	r18, r18
    383c:	33 1f       	adc	r19, r19
    383e:	6a 95       	dec	r22
    3840:	e2 f7       	brpl	.-8      	; 0x383a <sram_out+0x3a>
    3842:	82 2b       	or	r24, r18
    3844:	87 b9       	out	0x07, r24	; 7
				PORT_MOSI &= ~(1<<(channel));		//set all pins low
    3846:	88 b1       	in	r24, 0x08	; 8
    3848:	20 95       	com	r18
    384a:	28 23       	and	r18, r24
    384c:	28 b9       	out	0x08, r18	; 8
    384e:	08 95       	ret
			break;
			case 1:	//Soft high level via pull-ups (to respect 3V6 SRAM level)
				DDR_MOSI &= ~(1<<(channel));		//set all pins as inputs
    3850:	37 b1       	in	r19, 0x07	; 7
    3852:	81 e0       	ldi	r24, 0x01	; 1
    3854:	90 e0       	ldi	r25, 0x00	; 0
    3856:	02 c0       	rjmp	.+4      	; 0x385c <sram_out+0x5c>
    3858:	88 0f       	add	r24, r24
    385a:	99 1f       	adc	r25, r25
    385c:	6a 95       	dec	r22
    385e:	e2 f7       	brpl	.-8      	; 0x3858 <sram_out+0x58>
    3860:	28 2f       	mov	r18, r24
    3862:	20 95       	com	r18
    3864:	23 23       	and	r18, r19
    3866:	27 b9       	out	0x07, r18	; 7
				PORT_MOSI |= (1<<(channel));		//Activate pull-up on all pins
    3868:	28 b1       	in	r18, 0x08	; 8
    386a:	82 2b       	or	r24, r18
    386c:	88 b9       	out	0x08, r24	; 8
    386e:	08 95       	ret

00003870 <sram_clk>:
BOOTLOADER_SECTION void sram_clk(uchar val)
{
	//	DECRIPTION : Lowest level function used by intermediate level functions.
	// Directly set/clear the CLK pin
	// To be used for low speed clock or for SRAM setup phases.
	switch(val)
    3870:	88 23       	and	r24, r24
    3872:	19 f0       	breq	.+6      	; 0x387a <sram_clk+0xa>
    3874:	81 30       	cpi	r24, 0x01	; 1
    3876:	31 f4       	brne	.+12     	; 0x3884 <sram_clk+0x14>
    3878:	03 c0       	rjmp	.+6      	; 0x3880 <sram_clk+0x10>
	{
		case 0: //Hard low level
			DDR_CLK |= CLK;				//set pin as output
    387a:	23 9a       	sbi	0x04, 3	; 4
			PORT_CLK &= ~(CLK);		//set pin low
    387c:	2b 98       	cbi	0x05, 3	; 5
    387e:	08 95       	ret
		break;
		case 1:	//Soft high level via pull-ups (to respect 3V6 SRAM level)
			DDR_CLK |= CLK;				//set pin as output
    3880:	23 9a       	sbi	0x04, 3	; 4
			PORT_CLK |= CLK;		//Activate pull-up on pin
    3882:	2b 9a       	sbi	0x05, 3	; 5
    3884:	08 95       	ret

00003886 <sram_shift_byte_in>:
		sram_clk(1);
	}
}

BOOTLOADER_SECTION uchar sram_shift_byte_in(uchar channel)
{	
    3886:	ef 92       	push	r14
    3888:	ff 92       	push	r15
    388a:	0f 93       	push	r16
    388c:	1f 93       	push	r17
    388e:	df 93       	push	r29
    3890:	cf 93       	push	r28
    3892:	00 d0       	rcall	.+0      	; 0x3894 <sram_shift_byte_in+0xe>
    3894:	cd b7       	in	r28, 0x3d	; 61
    3896:	de b7       	in	r29, 0x3e	; 62
	//	DECRIPTION : Intermediate level function used by High level functions.
	//	Used to clock in 8 bit from the MISO line of the SRAM defined by
	//	"channel". 
	volatile uchar i,val = 0;
    3898:	1a 82       	std	Y+2, r1	; 0x02
	for(i=0;i<7;i++) //Get first 7 MSBs 
    389a:	19 82       	std	Y+1, r1	; 0x01
	{
		sram_clk(0);
		//sram_out_all((uchar)(val>>(7-i))&1); // write bit 
		sram_clk(1);
		val |= ((PIN_MISO & (1<<(channel+3)))>>(channel+3));
    389c:	08 2f       	mov	r16, r24
    389e:	10 e0       	ldi	r17, 0x00	; 0
    38a0:	0d 5f       	subi	r16, 0xFD	; 253
    38a2:	1f 4f       	sbci	r17, 0xFF	; 255
    38a4:	81 e0       	ldi	r24, 0x01	; 1
    38a6:	e8 2e       	mov	r14, r24
    38a8:	f1 2c       	mov	r15, r1
    38aa:	00 2e       	mov	r0, r16
    38ac:	02 c0       	rjmp	.+4      	; 0x38b2 <sram_shift_byte_in+0x2c>
    38ae:	ee 0c       	add	r14, r14
    38b0:	ff 1c       	adc	r15, r15
    38b2:	0a 94       	dec	r0
    38b4:	e2 f7       	brpl	.-8      	; 0x38ae <sram_shift_byte_in+0x28>
    38b6:	19 c0       	rjmp	.+50     	; 0x38ea <sram_shift_byte_in+0x64>
	//	Used to clock in 8 bit from the MISO line of the SRAM defined by
	//	"channel". 
	volatile uchar i,val = 0;
	for(i=0;i<7;i++) //Get first 7 MSBs 
	{
		sram_clk(0);
    38b8:	80 e0       	ldi	r24, 0x00	; 0
    38ba:	0e 94 38 1c 	call	0x3870	; 0x3870 <sram_clk>
		//sram_out_all((uchar)(val>>(7-i))&1); // write bit 
		sram_clk(1);
    38be:	81 e0       	ldi	r24, 0x01	; 1
    38c0:	0e 94 38 1c 	call	0x3870	; 0x3870 <sram_clk>
		val |= ((PIN_MISO & (1<<(channel+3)))>>(channel+3));
    38c4:	2a 81       	ldd	r18, Y+2	; 0x02
    38c6:	89 b1       	in	r24, 0x09	; 9
    38c8:	90 e0       	ldi	r25, 0x00	; 0
    38ca:	8e 21       	and	r24, r14
    38cc:	9f 21       	and	r25, r15
    38ce:	00 2e       	mov	r0, r16
    38d0:	02 c0       	rjmp	.+4      	; 0x38d6 <sram_shift_byte_in+0x50>
    38d2:	95 95       	asr	r25
    38d4:	87 95       	ror	r24
    38d6:	0a 94       	dec	r0
    38d8:	e2 f7       	brpl	.-8      	; 0x38d2 <sram_shift_byte_in+0x4c>
    38da:	28 2b       	or	r18, r24
    38dc:	2a 83       	std	Y+2, r18	; 0x02
		val = (val << 1);//shift left, make place for comming bit
    38de:	8a 81       	ldd	r24, Y+2	; 0x02
    38e0:	88 0f       	add	r24, r24
    38e2:	8a 83       	std	Y+2, r24	; 0x02
{	
	//	DECRIPTION : Intermediate level function used by High level functions.
	//	Used to clock in 8 bit from the MISO line of the SRAM defined by
	//	"channel". 
	volatile uchar i,val = 0;
	for(i=0;i<7;i++) //Get first 7 MSBs 
    38e4:	89 81       	ldd	r24, Y+1	; 0x01
    38e6:	8f 5f       	subi	r24, 0xFF	; 255
    38e8:	89 83       	std	Y+1, r24	; 0x01
    38ea:	89 81       	ldd	r24, Y+1	; 0x01
    38ec:	87 30       	cpi	r24, 0x07	; 7
    38ee:	20 f3       	brcs	.-56     	; 0x38b8 <sram_shift_byte_in+0x32>
		//sram_out_all((uchar)(val>>(7-i))&1); // write bit 
		sram_clk(1);
		val |= ((PIN_MISO & (1<<(channel+3)))>>(channel+3));
		val = (val << 1);//shift left, make place for comming bit
	}
	sram_clk(0); 	// Clock in last LSB
    38f0:	80 e0       	ldi	r24, 0x00	; 0
    38f2:	0e 94 38 1c 	call	0x3870	; 0x3870 <sram_clk>
	sram_clk(1);	// without shofting anymore to the left
    38f6:	81 e0       	ldi	r24, 0x01	; 1
    38f8:	0e 94 38 1c 	call	0x3870	; 0x3870 <sram_clk>
	val |= ((PIN_MISO & (1<<(channel+3)))>>(channel+3));
    38fc:	8a 81       	ldd	r24, Y+2	; 0x02
    38fe:	29 b1       	in	r18, 0x09	; 9
    3900:	30 e0       	ldi	r19, 0x00	; 0
    3902:	2e 21       	and	r18, r14
    3904:	3f 21       	and	r19, r15
    3906:	02 c0       	rjmp	.+4      	; 0x390c <sram_shift_byte_in+0x86>
    3908:	35 95       	asr	r19
    390a:	27 95       	ror	r18
    390c:	0a 95       	dec	r16
    390e:	e2 f7       	brpl	.-8      	; 0x3908 <sram_shift_byte_in+0x82>
    3910:	82 2b       	or	r24, r18
    3912:	8a 83       	std	Y+2, r24	; 0x02
	return val;
    3914:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3916:	0f 90       	pop	r0
    3918:	0f 90       	pop	r0
    391a:	cf 91       	pop	r28
    391c:	df 91       	pop	r29
    391e:	1f 91       	pop	r17
    3920:	0f 91       	pop	r16
    3922:	ff 90       	pop	r15
    3924:	ef 90       	pop	r14
    3926:	08 95       	ret

00003928 <sram_shit_out_word>:
	}
}


BOOTLOADER_SECTION void sram_shit_out_word(unsigned int val, uchar channel)
{
    3928:	ff 92       	push	r15
    392a:	0f 93       	push	r16
    392c:	1f 93       	push	r17
    392e:	cf 93       	push	r28
    3930:	df 93       	push	r29
    3932:	8c 01       	movw	r16, r24
    3934:	f6 2e       	mov	r15, r22
    3936:	cf e0       	ldi	r28, 0x0F	; 15
    3938:	d0 e0       	ldi	r29, 0x00	; 0
	//	by "channel". Mainly used to send a 16 bit address

	uchar i;
	for(i=16;i>0;i--) 
	{
		sram_out(((uchar)(val>>(i-1))&1), channel); // write bit 
    393a:	c8 01       	movw	r24, r16
    393c:	0c 2e       	mov	r0, r28
    393e:	02 c0       	rjmp	.+4      	; 0x3944 <sram_shit_out_word+0x1c>
    3940:	96 95       	lsr	r25
    3942:	87 95       	ror	r24
    3944:	0a 94       	dec	r0
    3946:	e2 f7       	brpl	.-8      	; 0x3940 <sram_shit_out_word+0x18>
    3948:	81 70       	andi	r24, 0x01	; 1
    394a:	6f 2d       	mov	r22, r15
    394c:	0e 94 00 1c 	call	0x3800	; 0x3800 <sram_out>
		sram_clk(0);		
    3950:	80 e0       	ldi	r24, 0x00	; 0
    3952:	0e 94 38 1c 	call	0x3870	; 0x3870 <sram_clk>
		sram_clk(1);
    3956:	81 e0       	ldi	r24, 0x01	; 1
    3958:	0e 94 38 1c 	call	0x3870	; 0x3870 <sram_clk>
    395c:	21 97       	sbiw	r28, 0x01	; 1
	//	DECRIPTION : Intermediate level function used by High level functions.
	//	Used to clock out the 16 bits of "val" on the MOSI of the SRAM defined
	//	by "channel". Mainly used to send a 16 bit address

	uchar i;
	for(i=16;i>0;i--) 
    395e:	8f ef       	ldi	r24, 0xFF	; 255
    3960:	cf 3f       	cpi	r28, 0xFF	; 255
    3962:	d8 07       	cpc	r29, r24
    3964:	51 f7       	brne	.-44     	; 0x393a <sram_shit_out_word+0x12>
	{
		sram_out(((uchar)(val>>(i-1))&1), channel); // write bit 
		sram_clk(0);		
		sram_clk(1);
	}
}
    3966:	df 91       	pop	r29
    3968:	cf 91       	pop	r28
    396a:	1f 91       	pop	r17
    396c:	0f 91       	pop	r16
    396e:	ff 90       	pop	r15
    3970:	08 95       	ret

00003972 <sram_shit_out_mixed_byte>:
		sram_clk(1);
	}
}

BOOTLOADER_SECTION void sram_shit_out_mixed_byte(uchar val1, uchar val2)
{
    3972:	cf 92       	push	r12
    3974:	df 92       	push	r13
    3976:	ef 92       	push	r14
    3978:	ff 92       	push	r15
    397a:	0f 93       	push	r16
    397c:	1f 93       	push	r17
    397e:	cf 93       	push	r28
    3980:	df 93       	push	r29
    3982:	c7 e0       	ldi	r28, 0x07	; 7
    3984:	d0 e0       	ldi	r29, 0x00	; 0
	// on channel 0,1 : shift out the byte "val1"
	// on channel 2,3 : shift out the byte "val2"
	uchar i;
	for(i=8;i>0;i--) 
	{
		sram_out(((uchar)(val2>>(i-1))&1), CH_ALL); // write bit 
    3986:	c6 2e       	mov	r12, r22
    3988:	dd 24       	eor	r13, r13
		sram_out(((uchar)(val1>>(i-1))&1), 0); // write bit 
    398a:	e8 2e       	mov	r14, r24
    398c:	ff 24       	eor	r15, r15
	// on channel 0,1 : shift out the byte "val1"
	// on channel 2,3 : shift out the byte "val2"
	uchar i;
	for(i=8;i>0;i--) 
	{
		sram_out(((uchar)(val2>>(i-1))&1), CH_ALL); // write bit 
    398e:	c6 01       	movw	r24, r12
    3990:	0c 2e       	mov	r0, r28
    3992:	02 c0       	rjmp	.+4      	; 0x3998 <sram_shit_out_mixed_byte+0x26>
    3994:	95 95       	asr	r25
    3996:	87 95       	ror	r24
    3998:	0a 94       	dec	r0
    399a:	e2 f7       	brpl	.-8      	; 0x3994 <sram_shit_out_mixed_byte+0x22>
    399c:	81 70       	andi	r24, 0x01	; 1
    399e:	63 e6       	ldi	r22, 0x63	; 99
    39a0:	0e 94 00 1c 	call	0x3800	; 0x3800 <sram_out>
		sram_out(((uchar)(val1>>(i-1))&1), 0); // write bit 
    39a4:	c7 01       	movw	r24, r14
    39a6:	0c 2e       	mov	r0, r28
    39a8:	02 c0       	rjmp	.+4      	; 0x39ae <sram_shit_out_mixed_byte+0x3c>
    39aa:	95 95       	asr	r25
    39ac:	87 95       	ror	r24
    39ae:	0a 94       	dec	r0
    39b0:	e2 f7       	brpl	.-8      	; 0x39aa <sram_shit_out_mixed_byte+0x38>
    39b2:	8c 01       	movw	r16, r24
    39b4:	01 70       	andi	r16, 0x01	; 1
    39b6:	80 2f       	mov	r24, r16
    39b8:	60 e0       	ldi	r22, 0x00	; 0
    39ba:	0e 94 00 1c 	call	0x3800	; 0x3800 <sram_out>
		sram_out(((uchar)(val1>>(i-1))&1), 1); // write bit 
    39be:	80 2f       	mov	r24, r16
    39c0:	61 e0       	ldi	r22, 0x01	; 1
    39c2:	0e 94 00 1c 	call	0x3800	; 0x3800 <sram_out>
		sram_clk(0);
    39c6:	80 e0       	ldi	r24, 0x00	; 0
    39c8:	0e 94 38 1c 	call	0x3870	; 0x3870 <sram_clk>
		sram_clk(1);
    39cc:	81 e0       	ldi	r24, 0x01	; 1
    39ce:	0e 94 38 1c 	call	0x3870	; 0x3870 <sram_clk>
    39d2:	21 97       	sbiw	r28, 0x01	; 1
	//	DECRIPTION : Intermediate level function used by High level functions.
	// Shift out differnet data on the channels : 
	// on channel 0,1 : shift out the byte "val1"
	// on channel 2,3 : shift out the byte "val2"
	uchar i;
	for(i=8;i>0;i--) 
    39d4:	9f ef       	ldi	r25, 0xFF	; 255
    39d6:	cf 3f       	cpi	r28, 0xFF	; 255
    39d8:	d9 07       	cpc	r29, r25
    39da:	c9 f6       	brne	.-78     	; 0x398e <sram_shit_out_mixed_byte+0x1c>
		sram_out(((uchar)(val1>>(i-1))&1), 0); // write bit 
		sram_out(((uchar)(val1>>(i-1))&1), 1); // write bit 
		sram_clk(0);
		sram_clk(1);
	}
}
    39dc:	df 91       	pop	r29
    39de:	cf 91       	pop	r28
    39e0:	1f 91       	pop	r17
    39e2:	0f 91       	pop	r16
    39e4:	ff 90       	pop	r15
    39e6:	ef 90       	pop	r14
    39e8:	df 90       	pop	r13
    39ea:	cf 90       	pop	r12
    39ec:	08 95       	ret

000039ee <sram_shit_out_byte>:
	sram_cs_end();
}


BOOTLOADER_SECTION void sram_shit_out_byte(uchar val, uchar channel)
{
    39ee:	ff 92       	push	r15
    39f0:	0f 93       	push	r16
    39f2:	1f 93       	push	r17
    39f4:	cf 93       	push	r28
    39f6:	df 93       	push	r29
    39f8:	f6 2e       	mov	r15, r22
    39fa:	c7 e0       	ldi	r28, 0x07	; 7
    39fc:	d0 e0       	ldi	r29, 0x00	; 0
	//	Used to clock out the 8 bits of "val" on the MOSI of the SRAM defined
	//	by "channel"
	uchar i;
	for(i=8;i>0;i--) 
	{
		sram_out(((uchar)(val>>(i-1))&1), channel); // write bit 
    39fe:	08 2f       	mov	r16, r24
    3a00:	10 e0       	ldi	r17, 0x00	; 0
    3a02:	c8 01       	movw	r24, r16
    3a04:	0c 2e       	mov	r0, r28
    3a06:	02 c0       	rjmp	.+4      	; 0x3a0c <sram_shit_out_byte+0x1e>
    3a08:	95 95       	asr	r25
    3a0a:	87 95       	ror	r24
    3a0c:	0a 94       	dec	r0
    3a0e:	e2 f7       	brpl	.-8      	; 0x3a08 <sram_shit_out_byte+0x1a>
    3a10:	81 70       	andi	r24, 0x01	; 1
    3a12:	6f 2d       	mov	r22, r15
    3a14:	0e 94 00 1c 	call	0x3800	; 0x3800 <sram_out>
		sram_clk(0);
    3a18:	80 e0       	ldi	r24, 0x00	; 0
    3a1a:	0e 94 38 1c 	call	0x3870	; 0x3870 <sram_clk>
		sram_clk(1);
    3a1e:	81 e0       	ldi	r24, 0x01	; 1
    3a20:	0e 94 38 1c 	call	0x3870	; 0x3870 <sram_clk>
    3a24:	21 97       	sbiw	r28, 0x01	; 1
{
	//	DECRIPTION : Intermediate level function used by High level functions.
	//	Used to clock out the 8 bits of "val" on the MOSI of the SRAM defined
	//	by "channel"
	uchar i;
	for(i=8;i>0;i--) 
    3a26:	8f ef       	ldi	r24, 0xFF	; 255
    3a28:	cf 3f       	cpi	r28, 0xFF	; 255
    3a2a:	d8 07       	cpc	r29, r24
    3a2c:	51 f7       	brne	.-44     	; 0x3a02 <sram_shit_out_byte+0x14>
	{
		sram_out(((uchar)(val>>(i-1))&1), channel); // write bit 
		sram_clk(0);
		sram_clk(1);
	}
}
    3a2e:	df 91       	pop	r29
    3a30:	cf 91       	pop	r28
    3a32:	1f 91       	pop	r17
    3a34:	0f 91       	pop	r16
    3a36:	ff 90       	pop	r15
    3a38:	08 95       	ret

00003a3a <sram_write_block>:
	}
	sram_cs_end();
}

BOOTLOADER_SECTION void sram_write_block(uchar channel,uchar len, uchar* data_store) //TO BE TESTED
{
    3a3a:	ff 92       	push	r15
    3a3c:	0f 93       	push	r16
    3a3e:	1f 93       	push	r17
    3a40:	cf 93       	push	r28
    3a42:	df 93       	push	r29
    3a44:	f8 2e       	mov	r15, r24
    3a46:	06 2f       	mov	r16, r22

	// NOTE : The SRAM must be in sequencial mode for this function to work properly, also, 
	// a new WRITE sequance must have been allready started with the correct start address

	uchar pointer=0;
	ISOLATE_PROBES
    3a48:	21 9a       	sbi	0x04, 1	; 4
    3a4a:	29 9a       	sbi	0x05, 1	; 5
    3a4c:	20 9a       	sbi	0x04, 0	; 4
    3a4e:	28 9a       	sbi	0x05, 0	; 5
    3a50:	22 9a       	sbi	0x04, 2	; 4
    3a52:	2a 9a       	sbi	0x05, 2	; 5
    3a54:	24 9a       	sbi	0x04, 4	; 4
    3a56:	2c 9a       	sbi	0x05, 4	; 5
    3a58:	ea 01       	movw	r28, r20
    3a5a:	10 e0       	ldi	r17, 0x00	; 0
    3a5c:	05 c0       	rjmp	.+10     	; 0x3a68 <sram_write_block+0x2e>
	//sram_cs_reset();
	//sram_shit_out_byte(INST_READ,channel);
	//sram_shit_out_word(add, channel);
	while (pointer < len)
	{
		sram_shit_out_byte(*(data_store+pointer),channel);
    3a5e:	89 91       	ld	r24, Y+
    3a60:	6f 2d       	mov	r22, r15
    3a62:	0e 94 f7 1c 	call	0x39ee	; 0x39ee <sram_shit_out_byte>
		pointer++;
    3a66:	1f 5f       	subi	r17, 0xFF	; 255
	uchar pointer=0;
	ISOLATE_PROBES
	//sram_cs_reset();
	//sram_shit_out_byte(INST_READ,channel);
	//sram_shit_out_word(add, channel);
	while (pointer < len)
    3a68:	10 17       	cp	r17, r16
    3a6a:	c8 f3       	brcs	.-14     	; 0x3a5e <sram_write_block+0x24>
	{
		sram_shit_out_byte(*(data_store+pointer),channel);
		pointer++;
	}
	//sram_cs_end();
}
    3a6c:	df 91       	pop	r29
    3a6e:	cf 91       	pop	r28
    3a70:	1f 91       	pop	r17
    3a72:	0f 91       	pop	r16
    3a74:	ff 90       	pop	r15
    3a76:	08 95       	ret

00003a78 <sram_cs_reset>:
}

BOOTLOADER_SECTION void sram_cs_reset()
{
	//	DECRIPTION : Initiate a new SPI sequence in a safe way on all SRAMS
	SRAM_CS_DIS;
    3a78:	57 98       	cbi	0x0a, 7	; 10
    3a7a:	5f 98       	cbi	0x0b, 7	; 11
	sram_clk(0);
    3a7c:	80 e0       	ldi	r24, 0x00	; 0
    3a7e:	0e 94 38 1c 	call	0x3870	; 0x3870 <sram_clk>
	SRAM_CS_ENA;
    3a82:	57 9a       	sbi	0x0a, 7	; 10
    3a84:	5f 98       	cbi	0x0b, 7	; 11
	sram_clk(0);
    3a86:	80 e0       	ldi	r24, 0x00	; 0
    3a88:	0e 94 38 1c 	call	0x3870	; 0x3870 <sram_clk>
}
    3a8c:	08 95       	ret

00003a8e <sram_single_setup>:
	sram_shit_out_mixed_byte(ch01_inst, ch23_inst); //send instructions
	sram_shit_out_word(add, CH_ALL);	//send start address
}

BOOTLOADER_SECTION void sram_single_setup(uchar inst, uchar ch, unsigned int add)
{
    3a8e:	ef 92       	push	r14
    3a90:	ff 92       	push	r15
    3a92:	0f 93       	push	r16
    3a94:	1f 93       	push	r17
    3a96:	e8 2e       	mov	r14, r24
    3a98:	f6 2e       	mov	r15, r22
    3a9a:	8a 01       	movw	r16, r20
	//	It can be used to setup the SRAMs for a mixed Playback/Record operation
	//	Can also be used for non mixed mode (all record or all playback)
	//
	//	This function is manly used for sequantial read/write of the SRAM
	//	and does not includes the SPI sequence termination on purpose.
	ISOLATE_PROBES
    3a9c:	21 9a       	sbi	0x04, 1	; 4
    3a9e:	29 9a       	sbi	0x05, 1	; 5
    3aa0:	20 9a       	sbi	0x04, 0	; 4
    3aa2:	28 9a       	sbi	0x05, 0	; 5
    3aa4:	22 9a       	sbi	0x04, 2	; 4
    3aa6:	2a 9a       	sbi	0x05, 2	; 5
    3aa8:	24 9a       	sbi	0x04, 4	; 4
    3aaa:	2c 9a       	sbi	0x05, 4	; 5
	sram_cs_reset();
    3aac:	0e 94 3c 1d 	call	0x3a78	; 0x3a78 <sram_cs_reset>
	sram_shit_out_byte(inst, ch); //send instructions
    3ab0:	8e 2d       	mov	r24, r14
    3ab2:	6f 2d       	mov	r22, r15
    3ab4:	0e 94 f7 1c 	call	0x39ee	; 0x39ee <sram_shit_out_byte>
	sram_shit_out_word(add, ch);	//send start address
    3ab8:	c8 01       	movw	r24, r16
    3aba:	6f 2d       	mov	r22, r15
    3abc:	0e 94 94 1c 	call	0x3928	; 0x3928 <sram_shit_out_word>
}
    3ac0:	1f 91       	pop	r17
    3ac2:	0f 91       	pop	r16
    3ac4:	ff 90       	pop	r15
    3ac6:	ef 90       	pop	r14
    3ac8:	08 95       	ret

00003aca <sram_mixed_setup>:
	}
}


BOOTLOADER_SECTION void sram_mixed_setup(uchar ch01_inst, uchar ch23_inst, unsigned int add)
{
    3aca:	ef 92       	push	r14
    3acc:	ff 92       	push	r15
    3ace:	0f 93       	push	r16
    3ad0:	1f 93       	push	r17
    3ad2:	18 2f       	mov	r17, r24
    3ad4:	06 2f       	mov	r16, r22
    3ad6:	7a 01       	movw	r14, r20
	//	It can be used to setup the SRAMs for a mixed Playback/Record operation
	//	Can also be used for non mixed mode (all record or all playback)
	//
	//	This function is manly used for sequantial read/write of the SRAM
	//	and does not includes the SPI sequence termination on purpose.
	ISOLATE_PROBES
    3ad8:	21 9a       	sbi	0x04, 1	; 4
    3ada:	29 9a       	sbi	0x05, 1	; 5
    3adc:	20 9a       	sbi	0x04, 0	; 4
    3ade:	28 9a       	sbi	0x05, 0	; 5
    3ae0:	22 9a       	sbi	0x04, 2	; 4
    3ae2:	2a 9a       	sbi	0x05, 2	; 5
    3ae4:	24 9a       	sbi	0x04, 4	; 4
    3ae6:	2c 9a       	sbi	0x05, 4	; 5
	sram_cs_reset();
    3ae8:	0e 94 3c 1d 	call	0x3a78	; 0x3a78 <sram_cs_reset>
	sram_shit_out_mixed_byte(ch01_inst, ch23_inst); //send instructions
    3aec:	81 2f       	mov	r24, r17
    3aee:	60 2f       	mov	r22, r16
    3af0:	0e 94 b9 1c 	call	0x3972	; 0x3972 <sram_shit_out_mixed_byte>
	sram_shit_out_word(add, CH_ALL);	//send start address
    3af4:	c7 01       	movw	r24, r14
    3af6:	63 e6       	ldi	r22, 0x63	; 99
    3af8:	0e 94 94 1c 	call	0x3928	; 0x3928 <sram_shit_out_word>
}
    3afc:	1f 91       	pop	r17
    3afe:	0f 91       	pop	r16
    3b00:	ff 90       	pop	r15
    3b02:	ef 90       	pop	r14
    3b04:	08 95       	ret

00003b06 <sram_cs_end>:
}

BOOTLOADER_SECTION void sram_cs_end()
{
	//	DECRIPTION : Terminates an SPI sequence on any/all SRAMS
	sram_clk(0);
    3b06:	80 e0       	ldi	r24, 0x00	; 0
    3b08:	0e 94 38 1c 	call	0x3870	; 0x3870 <sram_clk>
	SRAM_CS_DIS;
    3b0c:	57 98       	cbi	0x0a, 7	; 10
    3b0e:	5f 98       	cbi	0x0b, 7	; 11
}
    3b10:	08 95       	ret

00003b12 <sram_write_byte>:
	return val;
}


BOOTLOADER_SECTION void sram_write_byte(unsigned int add, uchar val, uchar channel)
{
    3b12:	ef 92       	push	r14
    3b14:	ff 92       	push	r15
    3b16:	0f 93       	push	r16
    3b18:	1f 93       	push	r17
    3b1a:	8c 01       	movw	r16, r24
    3b1c:	e6 2e       	mov	r14, r22
    3b1e:	f4 2e       	mov	r15, r20
	//	DECRIPTION : Writes the byte "val" at the address "add" on the 
	//	SRAM determined by "channel" which is value ranging from 0 to 3
	ISOLATE_PROBES
    3b20:	21 9a       	sbi	0x04, 1	; 4
    3b22:	29 9a       	sbi	0x05, 1	; 5
    3b24:	20 9a       	sbi	0x04, 0	; 4
    3b26:	28 9a       	sbi	0x05, 0	; 5
    3b28:	22 9a       	sbi	0x04, 2	; 4
    3b2a:	2a 9a       	sbi	0x05, 2	; 5
    3b2c:	24 9a       	sbi	0x04, 4	; 4
    3b2e:	2c 9a       	sbi	0x05, 4	; 5
	sram_cs_reset();
    3b30:	0e 94 3c 1d 	call	0x3a78	; 0x3a78 <sram_cs_reset>
	sram_shit_out_byte(INST_WRITE,channel);
    3b34:	82 e0       	ldi	r24, 0x02	; 2
    3b36:	6f 2d       	mov	r22, r15
    3b38:	0e 94 f7 1c 	call	0x39ee	; 0x39ee <sram_shit_out_byte>
	sram_shit_out_word(add, channel);
    3b3c:	c8 01       	movw	r24, r16
    3b3e:	6f 2d       	mov	r22, r15
    3b40:	0e 94 94 1c 	call	0x3928	; 0x3928 <sram_shit_out_word>
	sram_shit_out_byte(val,channel);
    3b44:	8e 2d       	mov	r24, r14
    3b46:	6f 2d       	mov	r22, r15
    3b48:	0e 94 f7 1c 	call	0x39ee	; 0x39ee <sram_shit_out_byte>
	sram_cs_end();
    3b4c:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <sram_cs_end>
}
    3b50:	1f 91       	pop	r17
    3b52:	0f 91       	pop	r16
    3b54:	ff 90       	pop	r15
    3b56:	ef 90       	pop	r14
    3b58:	08 95       	ret

00003b5a <sram_read_status>:
	sram_shit_out_byte(val,CH_ALL);
	sram_cs_end();
}

BOOTLOADER_SECTION uchar sram_read_status()
{
    3b5a:	1f 93       	push	r17
	//	DECRIPTION : Reads the STATUS register from SRAM number 0
	uchar val;
	ISOLATE_PROBES
    3b5c:	21 9a       	sbi	0x04, 1	; 4
    3b5e:	29 9a       	sbi	0x05, 1	; 5
    3b60:	20 9a       	sbi	0x04, 0	; 4
    3b62:	28 9a       	sbi	0x05, 0	; 5
    3b64:	22 9a       	sbi	0x04, 2	; 4
    3b66:	2a 9a       	sbi	0x05, 2	; 5
    3b68:	24 9a       	sbi	0x04, 4	; 4
    3b6a:	2c 9a       	sbi	0x05, 4	; 5
	val = 0;
	sram_cs_reset();
    3b6c:	0e 94 3c 1d 	call	0x3a78	; 0x3a78 <sram_cs_reset>
	sram_shit_out_byte(5,CH_ALL);
    3b70:	85 e0       	ldi	r24, 0x05	; 5
    3b72:	63 e6       	ldi	r22, 0x63	; 99
    3b74:	0e 94 f7 1c 	call	0x39ee	; 0x39ee <sram_shit_out_byte>
	val = sram_shift_byte_in(0);
    3b78:	80 e0       	ldi	r24, 0x00	; 0
    3b7a:	0e 94 43 1c 	call	0x3886	; 0x3886 <sram_shift_byte_in>
    3b7e:	18 2f       	mov	r17, r24
	sram_cs_end();
    3b80:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <sram_cs_end>
	return val;
}
    3b84:	81 2f       	mov	r24, r17
    3b86:	1f 91       	pop	r17
    3b88:	08 95       	ret

00003b8a <sram_write_status>:
	}
	//sram_cs_end();
}

BOOTLOADER_SECTION void sram_write_status(uchar val)
{
    3b8a:	1f 93       	push	r17
    3b8c:	18 2f       	mov	r17, r24
	//	DECRIPTION : Writes STATUS register with the byte "val" 
	//	for all SRAMS at the same time
	ISOLATE_PROBES
    3b8e:	21 9a       	sbi	0x04, 1	; 4
    3b90:	29 9a       	sbi	0x05, 1	; 5
    3b92:	20 9a       	sbi	0x04, 0	; 4
    3b94:	28 9a       	sbi	0x05, 0	; 5
    3b96:	22 9a       	sbi	0x04, 2	; 4
    3b98:	2a 9a       	sbi	0x05, 2	; 5
    3b9a:	24 9a       	sbi	0x04, 4	; 4
    3b9c:	2c 9a       	sbi	0x05, 4	; 5
	sram_cs_reset();
    3b9e:	0e 94 3c 1d 	call	0x3a78	; 0x3a78 <sram_cs_reset>
	sram_shit_out_byte(1,CH_ALL);
    3ba2:	81 e0       	ldi	r24, 0x01	; 1
    3ba4:	63 e6       	ldi	r22, 0x63	; 99
    3ba6:	0e 94 f7 1c 	call	0x39ee	; 0x39ee <sram_shit_out_byte>
	sram_shit_out_byte(val,CH_ALL);
    3baa:	81 2f       	mov	r24, r17
    3bac:	63 e6       	ldi	r22, 0x63	; 99
    3bae:	0e 94 f7 1c 	call	0x39ee	; 0x39ee <sram_shit_out_byte>
	sram_cs_end();
    3bb2:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <sram_cs_end>
}
    3bb6:	1f 91       	pop	r17
    3bb8:	08 95       	ret

00003bba <sram_read_block>:
	return val;
}


BOOTLOADER_SECTION void sram_read_block(unsigned int add, uchar channel,uchar len, uchar* data_store) //TESTED OK
{
    3bba:	cf 92       	push	r12
    3bbc:	df 92       	push	r13
    3bbe:	ef 92       	push	r14
    3bc0:	ff 92       	push	r15
    3bc2:	0f 93       	push	r16
    3bc4:	1f 93       	push	r17
    3bc6:	cf 93       	push	r28
    3bc8:	df 93       	push	r29
    3bca:	8c 01       	movw	r16, r24
    3bcc:	d6 2e       	mov	r13, r22
    3bce:	c4 2e       	mov	r12, r20
    3bd0:	f2 2e       	mov	r15, r18
    3bd2:	e3 2e       	mov	r14, r19
	//	value from 0 to 3. 
	// 	len : number of bytes to read
	//	

	uchar pointer=0;
	ISOLATE_PROBES
    3bd4:	21 9a       	sbi	0x04, 1	; 4
    3bd6:	29 9a       	sbi	0x05, 1	; 5
    3bd8:	20 9a       	sbi	0x04, 0	; 4
    3bda:	28 9a       	sbi	0x05, 0	; 5
    3bdc:	22 9a       	sbi	0x04, 2	; 4
    3bde:	2a 9a       	sbi	0x05, 2	; 5
    3be0:	24 9a       	sbi	0x04, 4	; 4
    3be2:	2c 9a       	sbi	0x05, 4	; 5
	sram_cs_reset();
    3be4:	0e 94 3c 1d 	call	0x3a78	; 0x3a78 <sram_cs_reset>
	sram_shit_out_byte(INST_READ,channel);
    3be8:	83 e0       	ldi	r24, 0x03	; 3
    3bea:	6d 2d       	mov	r22, r13
    3bec:	0e 94 f7 1c 	call	0x39ee	; 0x39ee <sram_shit_out_byte>
	sram_shit_out_word(add, channel);
    3bf0:	c8 01       	movw	r24, r16
    3bf2:	6d 2d       	mov	r22, r13
    3bf4:	0e 94 94 1c 	call	0x3928	; 0x3928 <sram_shit_out_word>
    3bf8:	2f 2d       	mov	r18, r15
    3bfa:	3e 2d       	mov	r19, r14
    3bfc:	c9 01       	movw	r24, r18
    3bfe:	ec 01       	movw	r28, r24
    3c00:	00 e0       	ldi	r16, 0x00	; 0
    3c02:	05 c0       	rjmp	.+10     	; 0x3c0e <sram_read_block+0x54>
	while (pointer < len)
	{
		*(data_store+pointer) = sram_shift_byte_in(channel);
    3c04:	8d 2d       	mov	r24, r13
    3c06:	0e 94 43 1c 	call	0x3886	; 0x3886 <sram_shift_byte_in>
    3c0a:	89 93       	st	Y+, r24
		pointer++;
    3c0c:	0f 5f       	subi	r16, 0xFF	; 255
	uchar pointer=0;
	ISOLATE_PROBES
	sram_cs_reset();
	sram_shit_out_byte(INST_READ,channel);
	sram_shit_out_word(add, channel);
	while (pointer < len)
    3c0e:	0c 15       	cp	r16, r12
    3c10:	c8 f3       	brcs	.-14     	; 0x3c04 <sram_read_block+0x4a>
	{
		*(data_store+pointer) = sram_shift_byte_in(channel);
		pointer++;
	}
	sram_cs_end();
    3c12:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <sram_cs_end>
}
    3c16:	df 91       	pop	r29
    3c18:	cf 91       	pop	r28
    3c1a:	1f 91       	pop	r17
    3c1c:	0f 91       	pop	r16
    3c1e:	ff 90       	pop	r15
    3c20:	ef 90       	pop	r14
    3c22:	df 90       	pop	r13
    3c24:	cf 90       	pop	r12
    3c26:	08 95       	ret

00003c28 <sram_read_byte>:
	sram_shit_out_byte(inst, ch); //send instructions
	sram_shit_out_word(add, ch);	//send start address
}

BOOTLOADER_SECTION uchar sram_read_byte(unsigned int add, uchar channel)
{
    3c28:	ef 92       	push	r14
    3c2a:	ff 92       	push	r15
    3c2c:	1f 93       	push	r17
    3c2e:	7c 01       	movw	r14, r24
    3c30:	16 2f       	mov	r17, r22
	//	DECRIPTION : Reads a byte of data at the address "add" 
	// 	from the SRAM determined by "channel" which is a 
	//	value from 0 to 3. 

	uchar val;
	ISOLATE_PROBES
    3c32:	21 9a       	sbi	0x04, 1	; 4
    3c34:	29 9a       	sbi	0x05, 1	; 5
    3c36:	20 9a       	sbi	0x04, 0	; 4
    3c38:	28 9a       	sbi	0x05, 0	; 5
    3c3a:	22 9a       	sbi	0x04, 2	; 4
    3c3c:	2a 9a       	sbi	0x05, 2	; 5
    3c3e:	24 9a       	sbi	0x04, 4	; 4
    3c40:	2c 9a       	sbi	0x05, 4	; 5
	sram_cs_reset();
    3c42:	0e 94 3c 1d 	call	0x3a78	; 0x3a78 <sram_cs_reset>
	sram_shit_out_byte(INST_READ,channel);
    3c46:	83 e0       	ldi	r24, 0x03	; 3
    3c48:	61 2f       	mov	r22, r17
    3c4a:	0e 94 f7 1c 	call	0x39ee	; 0x39ee <sram_shit_out_byte>
	sram_shit_out_word(add, channel);
    3c4e:	c7 01       	movw	r24, r14
    3c50:	61 2f       	mov	r22, r17
    3c52:	0e 94 94 1c 	call	0x3928	; 0x3928 <sram_shit_out_word>
	val = sram_shift_byte_in(channel);
    3c56:	81 2f       	mov	r24, r17
    3c58:	0e 94 43 1c 	call	0x3886	; 0x3886 <sram_shift_byte_in>
    3c5c:	18 2f       	mov	r17, r24

	sram_cs_end();
    3c5e:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <sram_cs_end>
	return val;
}
    3c62:	81 2f       	mov	r24, r17
    3c64:	1f 91       	pop	r17
    3c66:	ff 90       	pop	r15
    3c68:	ef 90       	pop	r14
    3c6a:	08 95       	ret

00003c6c <bootloader>:

#include "header.h"


BOOTLOADER_SECTION void bootloader()
{
    3c6c:	6f 92       	push	r6
    3c6e:	7f 92       	push	r7
    3c70:	8f 92       	push	r8
    3c72:	9f 92       	push	r9
    3c74:	af 92       	push	r10
    3c76:	bf 92       	push	r11
    3c78:	cf 92       	push	r12
    3c7a:	df 92       	push	r13
    3c7c:	ef 92       	push	r14
    3c7e:	ff 92       	push	r15
    3c80:	0f 93       	push	r16
    3c82:	1f 93       	push	r17
    3c84:	df 93       	push	r29
    3c86:	cf 93       	push	r28
    3c88:	cd b7       	in	r28, 0x3d	; 61
    3c8a:	de b7       	in	r29, 0x3e	; 62
    3c8c:	a0 97       	sbiw	r28, 0x20	; 32
    3c8e:	0f b6       	in	r0, 0x3f	; 63
    3c90:	f8 94       	cli
    3c92:	de bf       	out	0x3e, r29	; 62
    3c94:	0f be       	out	0x3f, r0	; 63
    3c96:	cd bf       	out	0x3d, r28	; 61
	volatile uint16_t xeeprom_add;
	volatile uint16_t i;
	volatile uint32_t temp_1,key,byte_counter,local_cycle,local_cycle_period;
	volatile uint16_t temp_2;

	key = 0x1FE2;
    3c98:	82 ee       	ldi	r24, 0xE2	; 226
    3c9a:	9f e1       	ldi	r25, 0x1F	; 31
    3c9c:	a0 e0       	ldi	r26, 0x00	; 0
    3c9e:	b0 e0       	ldi	r27, 0x00	; 0
    3ca0:	89 8b       	std	Y+17, r24	; 0x11
    3ca2:	9a 8b       	std	Y+18, r25	; 0x12
    3ca4:	ab 8b       	std	Y+19, r26	; 0x13
    3ca6:	bc 8b       	std	Y+20, r27	; 0x14
//	volatile uchar page_ok;

	cli();
    3ca8:	f8 94       	cli
	//Turn off the WDT
	MCUSR &= ~(1<<WDRF);
    3caa:	84 b7       	in	r24, 0x34	; 52
    3cac:	87 7f       	andi	r24, 0xF7	; 247
    3cae:	84 bf       	out	0x34, r24	; 52
	WDTCSR |= (1<<WDCE) | (1<<WDE); //Start timed sequence to edit watchdog configuration
    3cb0:	80 91 60 00 	lds	r24, 0x0060
    3cb4:	88 61       	ori	r24, 0x18	; 24
    3cb6:	80 93 60 00 	sts	0x0060, r24
	WDTCSR = 0;
    3cba:	10 92 60 00 	sts	0x0060, r1
	
	usbDeviceDisconnect();
    3cbe:	3d 98       	cbi	0x07, 5	; 7
    3cc0:	45 98       	cbi	0x08, 5	; 8
	
	
	for (page = 0; page < 112;page++)
    3cc2:	1a 82       	std	Y+2, r1	; 0x02
    3cc4:	19 82       	std	Y+1, r1	; 0x01
	{
		boot_spm_busy_wait ();
		eeprom_busy_wait ();
		boot_page_erase_safe (page*SPM_PAGESIZE);
    3cc6:	23 e0       	ldi	r18, 0x03	; 3
    3cc8:	1c c0       	rjmp	.+56     	; 0x3d02 <bootloader+0x96>
	usbDeviceDisconnect();
	
	
	for (page = 0; page < 112;page++)
	{
		boot_spm_busy_wait ();
    3cca:	07 b6       	in	r0, 0x37	; 55
    3ccc:	00 fc       	sbrc	r0, 0
    3cce:	fd cf       	rjmp	.-6      	; 0x3cca <bootloader+0x5e>
		eeprom_busy_wait ();
    3cd0:	f9 99       	sbic	0x1f, 1	; 31
    3cd2:	fe cf       	rjmp	.-4      	; 0x3cd0 <bootloader+0x64>
		boot_page_erase_safe (page*SPM_PAGESIZE);
    3cd4:	07 b6       	in	r0, 0x37	; 55
    3cd6:	00 fc       	sbrc	r0, 0
    3cd8:	fd cf       	rjmp	.-6      	; 0x3cd4 <bootloader+0x68>
    3cda:	f9 99       	sbic	0x1f, 1	; 31
    3cdc:	fe cf       	rjmp	.-4      	; 0x3cda <bootloader+0x6e>
    3cde:	e9 81       	ldd	r30, Y+1	; 0x01
    3ce0:	fa 81       	ldd	r31, Y+2	; 0x02
    3ce2:	f6 95       	lsr	r31
    3ce4:	fe 2f       	mov	r31, r30
    3ce6:	ee 27       	eor	r30, r30
    3ce8:	f7 95       	ror	r31
    3cea:	e7 95       	ror	r30
    3cec:	20 93 57 00 	sts	0x0057, r18
    3cf0:	e8 95       	spm
		boot_spm_busy_wait ();      // Wait until the memory is erased.
    3cf2:	07 b6       	in	r0, 0x37	; 55
    3cf4:	00 fc       	sbrc	r0, 0
    3cf6:	fd cf       	rjmp	.-6      	; 0x3cf2 <bootloader+0x86>
	WDTCSR = 0;
	
	usbDeviceDisconnect();
	
	
	for (page = 0; page < 112;page++)
    3cf8:	89 81       	ldd	r24, Y+1	; 0x01
    3cfa:	9a 81       	ldd	r25, Y+2	; 0x02
    3cfc:	01 96       	adiw	r24, 0x01	; 1
    3cfe:	9a 83       	std	Y+2, r25	; 0x02
    3d00:	89 83       	std	Y+1, r24	; 0x01
    3d02:	89 81       	ldd	r24, Y+1	; 0x01
    3d04:	9a 81       	ldd	r25, Y+2	; 0x02
    3d06:	80 37       	cpi	r24, 0x70	; 112
    3d08:	91 05       	cpc	r25, r1
    3d0a:	f8 f2       	brcs	.-66     	; 0x3cca <bootloader+0x5e>
		boot_spm_busy_wait ();
		eeprom_busy_wait ();
		boot_page_erase_safe (page*SPM_PAGESIZE);
		boot_spm_busy_wait ();      // Wait until the memory is erased.
	}
	LED_ON
    3d0c:	50 9a       	sbi	0x0a, 0	; 10
    3d0e:	58 9a       	sbi	0x0b, 0	; 11

	// DECRYPTION
	local_cycle = 0;
    3d10:	19 8e       	std	Y+25, r1	; 0x19
    3d12:	1a 8e       	std	Y+26, r1	; 0x1a
    3d14:	1b 8e       	std	Y+27, r1	; 0x1b
    3d16:	1c 8e       	std	Y+28, r1	; 0x1c
  local_cycle_period = 3;
    3d18:	83 e0       	ldi	r24, 0x03	; 3
    3d1a:	90 e0       	ldi	r25, 0x00	; 0
    3d1c:	a0 e0       	ldi	r26, 0x00	; 0
    3d1e:	b0 e0       	ldi	r27, 0x00	; 0
    3d20:	8d 8f       	std	Y+29, r24	; 0x1d
    3d22:	9e 8f       	std	Y+30, r25	; 0x1e
    3d24:	af 8f       	std	Y+31, r26	; 0x1f
    3d26:	b8 a3       	std	Y+32, r27	; 0x20
	temp_1 = 0;
    3d28:	1d 86       	std	Y+13, r1	; 0x0d
    3d2a:	1e 86       	std	Y+14, r1	; 0x0e
    3d2c:	1f 86       	std	Y+15, r1	; 0x0f
    3d2e:	18 8a       	std	Y+16, r1	; 0x10
	// END DECRIPTION

	for (page = 0; page < 112;page++)
    3d30:	1a 82       	std	Y+2, r1	; 0x02
    3d32:	19 82       	std	Y+1, r1	; 0x01
		xeeprom_add = (page_add);

		
		boot_spm_busy_wait();
		eeprom_busy_wait ();
		boot_page_erase(page_add);
    3d34:	63 e0       	ldi	r22, 0x03	; 3
    3d36:	66 2e       	mov	r6, r22
		boot_spm_busy_wait ();
		eeprom_busy_wait ();
		boot_rww_enable ();
    3d38:	51 e1       	ldi	r21, 0x11	; 17
    3d3a:	95 2e       	mov	r9, r21
					//****************************************************************************************************
					word = temp_2;

				//END OF DECRYPT THE WORD

        boot_page_fill_safe (page_add+ i, word);
    3d3c:	77 24       	eor	r7, r7
    3d3e:	73 94       	inc	r7
					{
	            local_cycle = 0;
	            local_cycle_period += 1;
	            if (local_cycle_period > 99)
							{
	                local_cycle_period = 3;
    3d40:	43 e0       	ldi	r20, 0x03	; 3
    3d42:	a4 2e       	mov	r10, r20
    3d44:	b1 2c       	mov	r11, r1
    3d46:	c1 2c       	mov	r12, r1
    3d48:	d1 2c       	mov	r13, r1

				//DECRYPTION RELATED PART
				byte_counter++;
    }

 		boot_page_write (page_add);     // Store buffer in flash page.
    3d4a:	35 e0       	ldi	r19, 0x05	; 5
    3d4c:	83 2e       	mov	r8, r19
    3d4e:	f5 c0       	rjmp	.+490    	; 0x3f3a <bootloader+0x2ce>
	// END DECRIPTION

	for (page = 0; page < 112;page++)
	{

		word = 0;
    3d50:	1e 82       	std	Y+6, r1	; 0x06
    3d52:	1d 82       	std	Y+5, r1	; 0x05
		page_add = page * SPM_PAGESIZE;
    3d54:	89 81       	ldd	r24, Y+1	; 0x01
    3d56:	9a 81       	ldd	r25, Y+2	; 0x02
    3d58:	96 95       	lsr	r25
    3d5a:	98 2f       	mov	r25, r24
    3d5c:	88 27       	eor	r24, r24
    3d5e:	97 95       	ror	r25
    3d60:	87 95       	ror	r24
    3d62:	9c 83       	std	Y+4, r25	; 0x04
    3d64:	8b 83       	std	Y+3, r24	; 0x03
		xeeprom_add = (page_add);
    3d66:	8b 81       	ldd	r24, Y+3	; 0x03
    3d68:	9c 81       	ldd	r25, Y+4	; 0x04
    3d6a:	98 87       	std	Y+8, r25	; 0x08
    3d6c:	8f 83       	std	Y+7, r24	; 0x07

		
		boot_spm_busy_wait();
    3d6e:	07 b6       	in	r0, 0x37	; 55
    3d70:	00 fc       	sbrc	r0, 0
    3d72:	fd cf       	rjmp	.-6      	; 0x3d6e <bootloader+0x102>
		eeprom_busy_wait ();
    3d74:	f9 99       	sbic	0x1f, 1	; 31
    3d76:	fe cf       	rjmp	.-4      	; 0x3d74 <bootloader+0x108>
		boot_page_erase(page_add);
    3d78:	eb 81       	ldd	r30, Y+3	; 0x03
    3d7a:	fc 81       	ldd	r31, Y+4	; 0x04
    3d7c:	60 92 57 00 	sts	0x0057, r6
    3d80:	e8 95       	spm
		boot_spm_busy_wait ();
    3d82:	07 b6       	in	r0, 0x37	; 55
    3d84:	00 fc       	sbrc	r0, 0
    3d86:	fd cf       	rjmp	.-6      	; 0x3d82 <bootloader+0x116>
		eeprom_busy_wait ();
    3d88:	f9 99       	sbic	0x1f, 1	; 31
    3d8a:	fe cf       	rjmp	.-4      	; 0x3d88 <bootloader+0x11c>
		boot_rww_enable ();
    3d8c:	90 92 57 00 	sts	0x0057, r9
    3d90:	e8 95       	spm
		boot_spm_busy_wait();
    3d92:	07 b6       	in	r0, 0x37	; 55
    3d94:	00 fc       	sbrc	r0, 0
    3d96:	fd cf       	rjmp	.-6      	; 0x3d92 <bootloader+0x126>
		eeprom_busy_wait ();
    3d98:	f9 99       	sbic	0x1f, 1	; 31
    3d9a:	fe cf       	rjmp	.-4      	; 0x3d98 <bootloader+0x12c>


		for (i=0; i<SPM_PAGESIZE; i+=2)
    3d9c:	1a 86       	std	Y+10, r1	; 0x0a
    3d9e:	19 86       	std	Y+9, r1	; 0x09
    3da0:	ac c0       	rjmp	.+344    	; 0x3efa <bootloader+0x28e>
    {
        // Set up little-endian word.
        word = sram_read_byte(xeeprom_add++,0);
    3da2:	8f 81       	ldd	r24, Y+7	; 0x07
    3da4:	98 85       	ldd	r25, Y+8	; 0x08
    3da6:	01 96       	adiw	r24, 0x01	; 1
    3da8:	98 87       	std	Y+8, r25	; 0x08
    3daa:	8f 83       	std	Y+7, r24	; 0x07
    3dac:	01 97       	sbiw	r24, 0x01	; 1
    3dae:	60 e0       	ldi	r22, 0x00	; 0
    3db0:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <sram_read_byte>
    3db4:	90 e0       	ldi	r25, 0x00	; 0
    3db6:	9e 83       	std	Y+6, r25	; 0x06
    3db8:	8d 83       	std	Y+5, r24	; 0x05
        word += (sram_read_byte(xeeprom_add++,0)) << 8;
    3dba:	0d 81       	ldd	r16, Y+5	; 0x05
    3dbc:	1e 81       	ldd	r17, Y+6	; 0x06
    3dbe:	8f 81       	ldd	r24, Y+7	; 0x07
    3dc0:	98 85       	ldd	r25, Y+8	; 0x08
    3dc2:	01 96       	adiw	r24, 0x01	; 1
    3dc4:	98 87       	std	Y+8, r25	; 0x08
    3dc6:	8f 83       	std	Y+7, r24	; 0x07
    3dc8:	01 97       	sbiw	r24, 0x01	; 1
    3dca:	60 e0       	ldi	r22, 0x00	; 0
    3dcc:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <sram_read_byte>
    3dd0:	f8 2e       	mov	r15, r24
    3dd2:	ee 24       	eor	r14, r14
    3dd4:	0e 0d       	add	r16, r14
    3dd6:	1f 1d       	adc	r17, r15
    3dd8:	1e 83       	std	Y+6, r17	; 0x06
    3dda:	0d 83       	std	Y+5, r16	; 0x05
				
				//DECRYPT THE WORD
					temp_2 = word;
    3ddc:	8d 81       	ldd	r24, Y+5	; 0x05
    3dde:	9e 81       	ldd	r25, Y+6	; 0x06
    3de0:	9c 87       	std	Y+12, r25	; 0x0c
    3de2:	8b 87       	std	Y+11, r24	; 0x0b
					local_cycle += 1;
    3de4:	89 8d       	ldd	r24, Y+25	; 0x19
    3de6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3de8:	ab 8d       	ldd	r26, Y+27	; 0x1b
    3dea:	bc 8d       	ldd	r27, Y+28	; 0x1c
    3dec:	01 96       	adiw	r24, 0x01	; 1
    3dee:	a1 1d       	adc	r26, r1
    3df0:	b1 1d       	adc	r27, r1
    3df2:	89 8f       	std	Y+25, r24	; 0x19
    3df4:	9a 8f       	std	Y+26, r25	; 0x1a
    3df6:	ab 8f       	std	Y+27, r26	; 0x1b
    3df8:	bc 8f       	std	Y+28, r27	; 0x1c
	        if (local_cycle > local_cycle_period)
    3dfa:	29 8d       	ldd	r18, Y+25	; 0x19
    3dfc:	3a 8d       	ldd	r19, Y+26	; 0x1a
    3dfe:	4b 8d       	ldd	r20, Y+27	; 0x1b
    3e00:	5c 8d       	ldd	r21, Y+28	; 0x1c
    3e02:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3e04:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3e06:	af 8d       	ldd	r26, Y+31	; 0x1f
    3e08:	b8 a1       	ldd	r27, Y+32	; 0x20
    3e0a:	82 17       	cp	r24, r18
    3e0c:	93 07       	cpc	r25, r19
    3e0e:	a4 07       	cpc	r26, r20
    3e10:	b5 07       	cpc	r27, r21
    3e12:	e0 f4       	brcc	.+56     	; 0x3e4c <bootloader+0x1e0>
					{
	            local_cycle = 0;
    3e14:	19 8e       	std	Y+25, r1	; 0x19
    3e16:	1a 8e       	std	Y+26, r1	; 0x1a
    3e18:	1b 8e       	std	Y+27, r1	; 0x1b
    3e1a:	1c 8e       	std	Y+28, r1	; 0x1c
	            local_cycle_period += 1;
    3e1c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3e1e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3e20:	af 8d       	ldd	r26, Y+31	; 0x1f
    3e22:	b8 a1       	ldd	r27, Y+32	; 0x20
    3e24:	01 96       	adiw	r24, 0x01	; 1
    3e26:	a1 1d       	adc	r26, r1
    3e28:	b1 1d       	adc	r27, r1
    3e2a:	8d 8f       	std	Y+29, r24	; 0x1d
    3e2c:	9e 8f       	std	Y+30, r25	; 0x1e
    3e2e:	af 8f       	std	Y+31, r26	; 0x1f
    3e30:	b8 a3       	std	Y+32, r27	; 0x20
	            if (local_cycle_period > 99)
    3e32:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3e34:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3e36:	af 8d       	ldd	r26, Y+31	; 0x1f
    3e38:	b8 a1       	ldd	r27, Y+32	; 0x20
    3e3a:	84 36       	cpi	r24, 0x64	; 100
    3e3c:	91 05       	cpc	r25, r1
    3e3e:	a1 05       	cpc	r26, r1
    3e40:	b1 05       	cpc	r27, r1
    3e42:	20 f0       	brcs	.+8      	; 0x3e4c <bootloader+0x1e0>
							{
	                local_cycle_period = 3;
    3e44:	ad 8e       	std	Y+29, r10	; 0x1d
    3e46:	be 8e       	std	Y+30, r11	; 0x1e
    3e48:	cf 8e       	std	Y+31, r12	; 0x1f
    3e4a:	d8 a2       	std	Y+32, r13	; 0x20
	            }
	        }

					temp_1 = temp_1 + key ;//+ (local_cycle * 256) + (256 - local_cycle) + local_cycle_period ;
    3e4c:	2d 85       	ldd	r18, Y+13	; 0x0d
    3e4e:	3e 85       	ldd	r19, Y+14	; 0x0e
    3e50:	4f 85       	ldd	r20, Y+15	; 0x0f
    3e52:	58 89       	ldd	r21, Y+16	; 0x10
    3e54:	89 89       	ldd	r24, Y+17	; 0x11
    3e56:	9a 89       	ldd	r25, Y+18	; 0x12
    3e58:	ab 89       	ldd	r26, Y+19	; 0x13
    3e5a:	bc 89       	ldd	r27, Y+20	; 0x14
    3e5c:	82 0f       	add	r24, r18
    3e5e:	93 1f       	adc	r25, r19
    3e60:	a4 1f       	adc	r26, r20
    3e62:	b5 1f       	adc	r27, r21
    3e64:	08 c0       	rjmp	.+16     	; 0x3e76 <bootloader+0x20a>

					while (temp_1 > 65535)
					{
                    temp_1 -= 65536;
    3e66:	8d 85       	ldd	r24, Y+13	; 0x0d
    3e68:	9e 85       	ldd	r25, Y+14	; 0x0e
    3e6a:	af 85       	ldd	r26, Y+15	; 0x0f
    3e6c:	b8 89       	ldd	r27, Y+16	; 0x10
    3e6e:	80 50       	subi	r24, 0x00	; 0
    3e70:	90 40       	sbci	r25, 0x00	; 0
    3e72:	a1 40       	sbci	r26, 0x01	; 1
    3e74:	b0 40       	sbci	r27, 0x00	; 0
    3e76:	8d 87       	std	Y+13, r24	; 0x0d
    3e78:	9e 87       	std	Y+14, r25	; 0x0e
    3e7a:	af 87       	std	Y+15, r26	; 0x0f
    3e7c:	b8 8b       	std	Y+16, r27	; 0x10
	            }
	        }

					temp_1 = temp_1 + key ;//+ (local_cycle * 256) + (256 - local_cycle) + local_cycle_period ;

					while (temp_1 > 65535)
    3e7e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3e80:	9e 85       	ldd	r25, Y+14	; 0x0e
    3e82:	af 85       	ldd	r26, Y+15	; 0x0f
    3e84:	b8 89       	ldd	r27, Y+16	; 0x10
    3e86:	80 50       	subi	r24, 0x00	; 0
    3e88:	90 40       	sbci	r25, 0x00	; 0
    3e8a:	a1 40       	sbci	r26, 0x01	; 1
    3e8c:	b0 40       	sbci	r27, 0x00	; 0
    3e8e:	58 f7       	brcc	.-42     	; 0x3e66 <bootloader+0x1fa>
					{
                    temp_1 -= 65536;
          }

	        temp_2 = temp_2 ^ (uint16_t)temp_1;
    3e90:	8b 85       	ldd	r24, Y+11	; 0x0b
    3e92:	9c 85       	ldd	r25, Y+12	; 0x0c
    3e94:	2d 85       	ldd	r18, Y+13	; 0x0d
    3e96:	3e 85       	ldd	r19, Y+14	; 0x0e
    3e98:	4f 85       	ldd	r20, Y+15	; 0x0f
    3e9a:	58 89       	ldd	r21, Y+16	; 0x10
    3e9c:	82 27       	eor	r24, r18
    3e9e:	93 27       	eor	r25, r19
    3ea0:	9c 87       	std	Y+12, r25	; 0x0c
    3ea2:	8b 87       	std	Y+11, r24	; 0x0b
					
					
					//****************************************************************************************************
					word = temp_2;
    3ea4:	8b 85       	ldd	r24, Y+11	; 0x0b
    3ea6:	9c 85       	ldd	r25, Y+12	; 0x0c
    3ea8:	9e 83       	std	Y+6, r25	; 0x06
    3eaa:	8d 83       	std	Y+5, r24	; 0x05

				//END OF DECRYPT THE WORD

        boot_page_fill_safe (page_add+ i, word);
    3eac:	07 b6       	in	r0, 0x37	; 55
    3eae:	00 fc       	sbrc	r0, 0
    3eb0:	fd cf       	rjmp	.-6      	; 0x3eac <bootloader+0x240>
    3eb2:	f9 99       	sbic	0x1f, 1	; 31
    3eb4:	fe cf       	rjmp	.-4      	; 0x3eb2 <bootloader+0x246>
    3eb6:	8b 81       	ldd	r24, Y+3	; 0x03
    3eb8:	9c 81       	ldd	r25, Y+4	; 0x04
    3eba:	e9 85       	ldd	r30, Y+9	; 0x09
    3ebc:	fa 85       	ldd	r31, Y+10	; 0x0a
    3ebe:	2d 81       	ldd	r18, Y+5	; 0x05
    3ec0:	3e 81       	ldd	r19, Y+6	; 0x06
    3ec2:	e8 0f       	add	r30, r24
    3ec4:	f9 1f       	adc	r31, r25
    3ec6:	09 01       	movw	r0, r18
    3ec8:	70 92 57 00 	sts	0x0057, r7
    3ecc:	e8 95       	spm
    3ece:	11 24       	eor	r1, r1
				boot_spm_busy_wait();
    3ed0:	07 b6       	in	r0, 0x37	; 55
    3ed2:	00 fc       	sbrc	r0, 0
    3ed4:	fd cf       	rjmp	.-6      	; 0x3ed0 <bootloader+0x264>
				eeprom_busy_wait ();
    3ed6:	f9 99       	sbic	0x1f, 1	; 31
    3ed8:	fe cf       	rjmp	.-4      	; 0x3ed6 <bootloader+0x26a>


				//DECRYPTION RELATED PART
				byte_counter++;
    3eda:	8d 89       	ldd	r24, Y+21	; 0x15
    3edc:	9e 89       	ldd	r25, Y+22	; 0x16
    3ede:	af 89       	ldd	r26, Y+23	; 0x17
    3ee0:	b8 8d       	ldd	r27, Y+24	; 0x18
    3ee2:	01 96       	adiw	r24, 0x01	; 1
    3ee4:	a1 1d       	adc	r26, r1
    3ee6:	b1 1d       	adc	r27, r1
    3ee8:	8d 8b       	std	Y+21, r24	; 0x15
    3eea:	9e 8b       	std	Y+22, r25	; 0x16
    3eec:	af 8b       	std	Y+23, r26	; 0x17
    3eee:	b8 8f       	std	Y+24, r27	; 0x18
		boot_rww_enable ();
		boot_spm_busy_wait();
		eeprom_busy_wait ();


		for (i=0; i<SPM_PAGESIZE; i+=2)
    3ef0:	89 85       	ldd	r24, Y+9	; 0x09
    3ef2:	9a 85       	ldd	r25, Y+10	; 0x0a
    3ef4:	02 96       	adiw	r24, 0x02	; 2
    3ef6:	9a 87       	std	Y+10, r25	; 0x0a
    3ef8:	89 87       	std	Y+9, r24	; 0x09
    3efa:	89 85       	ldd	r24, Y+9	; 0x09
    3efc:	9a 85       	ldd	r25, Y+10	; 0x0a
    3efe:	80 38       	cpi	r24, 0x80	; 128
    3f00:	91 05       	cpc	r25, r1
    3f02:	08 f4       	brcc	.+2      	; 0x3f06 <bootloader+0x29a>
    3f04:	4e cf       	rjmp	.-356    	; 0x3da2 <bootloader+0x136>

				//DECRYPTION RELATED PART
				byte_counter++;
    }

 		boot_page_write (page_add);     // Store buffer in flash page.
    3f06:	eb 81       	ldd	r30, Y+3	; 0x03
    3f08:	fc 81       	ldd	r31, Y+4	; 0x04
    3f0a:	80 92 57 00 	sts	0x0057, r8
    3f0e:	e8 95       	spm
    boot_spm_busy_wait();  
    3f10:	07 b6       	in	r0, 0x37	; 55
    3f12:	00 fc       	sbrc	r0, 0
    3f14:	fd cf       	rjmp	.-6      	; 0x3f10 <bootloader+0x2a4>
		eeprom_busy_wait ();
    3f16:	f9 99       	sbic	0x1f, 1	; 31
    3f18:	fe cf       	rjmp	.-4      	; 0x3f16 <bootloader+0x2aa>
		boot_rww_enable ();
    3f1a:	90 92 57 00 	sts	0x0057, r9
    3f1e:	e8 95       	spm
		boot_spm_busy_wait();
    3f20:	07 b6       	in	r0, 0x37	; 55
    3f22:	00 fc       	sbrc	r0, 0
    3f24:	fd cf       	rjmp	.-6      	; 0x3f20 <bootloader+0x2b4>
		eeprom_busy_wait ();
    3f26:	f9 99       	sbic	0x1f, 1	; 31
    3f28:	fe cf       	rjmp	.-4      	; 0x3f26 <bootloader+0x2ba>
		while (boot_rww_busy());
    3f2a:	07 b6       	in	r0, 0x37	; 55
    3f2c:	06 fc       	sbrc	r0, 6
    3f2e:	fd cf       	rjmp	.-6      	; 0x3f2a <bootloader+0x2be>
	local_cycle = 0;
  local_cycle_period = 3;
	temp_1 = 0;
	// END DECRIPTION

	for (page = 0; page < 112;page++)
    3f30:	89 81       	ldd	r24, Y+1	; 0x01
    3f32:	9a 81       	ldd	r25, Y+2	; 0x02
    3f34:	01 96       	adiw	r24, 0x01	; 1
    3f36:	9a 83       	std	Y+2, r25	; 0x02
    3f38:	89 83       	std	Y+1, r24	; 0x01
    3f3a:	89 81       	ldd	r24, Y+1	; 0x01
    3f3c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f3e:	80 37       	cpi	r24, 0x70	; 112
    3f40:	91 05       	cpc	r25, r1
    3f42:	08 f4       	brcc	.+2      	; 0x3f46 <bootloader+0x2da>
    3f44:	05 cf       	rjmp	.-502    	; 0x3d50 <bootloader+0xe4>
		//}
		
	}


	wdt_enable(WDTO_4S);
    3f46:	28 e2       	ldi	r18, 0x28	; 40
    3f48:	88 e1       	ldi	r24, 0x18	; 24
    3f4a:	90 e0       	ldi	r25, 0x00	; 0
    3f4c:	0f b6       	in	r0, 0x3f	; 63
    3f4e:	f8 94       	cli
    3f50:	a8 95       	wdr
    3f52:	80 93 60 00 	sts	0x0060, r24
    3f56:	0f be       	out	0x3f, r0	; 63
    3f58:	20 93 60 00 	sts	0x0060, r18
	
	while(1){ 
		LED_OFF
    3f5c:	50 9a       	sbi	0x0a, 0	; 10
    3f5e:	58 98       	cbi	0x0b, 0	; 11
    3f60:	fd cf       	rjmp	.-6      	; 0x3f5c <bootloader+0x2f0>

00003f62 <sram_sequence_setup>:

	//	Controlling the frequency : 	
	//  "freq_val" Controls the value of OCR2A register
	
	//	
	sram_sequence_busy = 0;
    3f62:	10 92 12 01 	sts	0x0112, r1
	SRAM_HS_CLK_DIS
    3f66:	2f 9a       	sbi	0x05, 7	; 5
    3f68:	23 9a       	sbi	0x04, 3	; 4
    3f6a:	2b 98       	cbi	0x05, 3	; 5
	//timer 1 is used to stop timer 2
	TCCR1A = 0;
    3f6c:	10 92 80 00 	sts	0x0080, r1
	OCR1A = stop_val; 
    3f70:	50 93 89 00 	sts	0x0089, r21
    3f74:	40 93 88 00 	sts	0x0088, r20
	TCCR1B = 0;
    3f78:	10 92 81 00 	sts	0x0081, r1
	TCCR1B_temp = (1<<WGM12)|((stop_clk_sel&0x7)<<CS00); 
    3f7c:	87 70       	andi	r24, 0x07	; 7
    3f7e:	88 60       	ori	r24, 0x08	; 8
    3f80:	80 93 15 01 	sts	0x0115, r24
	TCNT1 = 0;
    3f84:	10 92 85 00 	sts	0x0085, r1
    3f88:	10 92 84 00 	sts	0x0084, r1
	TIMSK1 |= (1<<OCIE1A); //activate interrupts
    3f8c:	ef e6       	ldi	r30, 0x6F	; 111
    3f8e:	f0 e0       	ldi	r31, 0x00	; 0
    3f90:	80 81       	ld	r24, Z
    3f92:	82 60       	ori	r24, 0x02	; 2
    3f94:	80 83       	st	Z, r24


	//timer 2 is used to generate the clk
	TCCR2A |= (1<<WGM21);
    3f96:	e0 eb       	ldi	r30, 0xB0	; 176
    3f98:	f0 e0       	ldi	r31, 0x00	; 0
    3f9a:	80 81       	ld	r24, Z
    3f9c:	82 60       	ori	r24, 0x02	; 2
    3f9e:	80 83       	st	Z, r24
	TCCR2B |= (freq_clk_sel&0x7);
    3fa0:	e1 eb       	ldi	r30, 0xB1	; 177
    3fa2:	f0 e0       	ldi	r31, 0x00	; 0
    3fa4:	80 81       	ld	r24, Z
    3fa6:	67 70       	andi	r22, 0x07	; 7
    3fa8:	86 2b       	or	r24, r22
    3faa:	80 83       	st	Z, r24
	OCR2A = freq_val;	
    3fac:	20 93 b3 00 	sts	0x00B3, r18
}
    3fb0:	08 95       	ret

00003fb2 <sram_sequence_start>:

BOOTLOADER_SECTION void sram_sequence_start()
{
	//start T2 which generates the clk
	TCCR2A |= (1<<COM2A0);
    3fb2:	e0 eb       	ldi	r30, 0xB0	; 176
    3fb4:	f0 e0       	ldi	r31, 0x00	; 0
    3fb6:	80 81       	ld	r24, Z
    3fb8:	80 64       	ori	r24, 0x40	; 64
    3fba:	80 83       	st	Z, r24
	//start T1
	TCCR1B = TCCR1B_temp;
    3fbc:	80 91 15 01 	lds	r24, 0x0115
    3fc0:	80 93 81 00 	sts	0x0081, r24
	sram_sequence_busy = 1;	
    3fc4:	81 e0       	ldi	r24, 0x01	; 1
    3fc6:	80 93 12 01 	sts	0x0112, r24
}
    3fca:	08 95       	ret

00003fcc <sram_internal_clk>:

BOOTLOADER_SECTION void sram_internal_clk(uchar mode, uchar clk_sel,uchar val) //now this function will be used to set the lock bits
{

	boot_lock_bits_set(mode);
    3fcc:	80 95       	com	r24
    3fce:	99 e0       	ldi	r25, 0x09	; 9
    3fd0:	e1 e0       	ldi	r30, 0x01	; 1
    3fd2:	f0 e0       	ldi	r31, 0x00	; 0
    3fd4:	08 2e       	mov	r0, r24
    3fd6:	90 93 57 00 	sts	0x0057, r25
    3fda:	e8 95       	spm
	TCCR2A = ((mode&0x3)<<COM2A0) | (1<<WGM21);
	TCCR2B = (clk_sel&0x7);
	OCR2A = val;
	*/

}
    3fdc:	08 95       	ret
